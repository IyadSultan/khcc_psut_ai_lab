# Combined Python and HTML files
# Generated from directory: C:\Users\USER\Documents\khcc_psut_ai_lab\khcc_psut_ai_lab\projects
# Total files found: 26



# Contents from: .\utils\team_emails.html
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings

def send_team_notification_email(user, team, notification_type, context=None):
    """Send email notifications for team activities"""
    if context is None:
        context = {}
    
    context.update({
        'user': user,
        'team': team,
        'site_url': settings.SITE_URL
    })
    
    templates = {
        'discussion': 'emails/team_discussion.html',
        'comment': 'emails/team_comment.html',
        'role_change': 'emails/team_role_change.html',
        'invitation': 'emails/team_invitation.html'
    }
    
    template = templates.get(notification_type)
    if not template:
        return
        
    html_message = render_to_string(template, context)
    plain_message = strip_tags(html_message)
    
    subject = f"New activity in {team.name} - {notification_type.title()}"
    
    send_mail(
        subject,
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

def send_team_invitation_email(user, team, inviter):
    """Send email for team invitation"""
    context = {
        'user': user,
        'team': team,
        'inviter': inviter,
        'site_url': settings.SITE_URL
    }
    
    html_message = render_to_string('emails/team_invitation.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        f"Invitation to join {team.name}",
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

def send_role_change_notification(user, team, new_role):
    """Send email for role changes"""
    context = {
        'user': user,
        'team': team,
        'new_role': new_role,
        'site_url': settings.SITE_URL
    }
    
    html_message = render_to_string('emails/team_role_change.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        f"Role update in {team.name}",
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

# Contents from: .\__init__.py


# Contents from: .\admin.py
# projects/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from django.db.models import Count, Sum
from django.utils.html import format_html
from django.urls import reverse
from django.utils.safestring import mark_safe
from .models import (
    Project, Comment, Clap, UserProfile, Rating,
    Bookmark, ProjectAnalytics, Notification, Follow
)
from allauth.account.models import EmailAddress
from django.contrib import messages

# Extend UserProfile admin to include faculty-specific fields
class UserProfileInline(admin.StackedInline):
    model = UserProfile
    can_delete = False
    verbose_name_plural = 'Profile'
    fieldsets = (
        ('Basic Information', {
            'fields': ('avatar', 'bio', 'location', 'website')
        }),
        ('Professional Information', {
            'fields': ('title', 'department', 'research_interests')
        }),
        ('Social Media', {
            'fields': ('github_username', 'linkedin_url', 'twitter_username')
        }),
        ('Notification Settings', {
            'fields': (
                'email_on_comment', 'email_on_follow',
                'email_on_clap', 'email_on_bookmark'
            ),
            'classes': ('collapse',)
        })
    )

class EmailAddressInline(admin.StackedInline):
    model = EmailAddress
    extra = 0
    can_delete = True
    verbose_name = 'Email Address'
    verbose_name_plural = 'Email Addresses'

# Customize the User admin to include profile information
class UserAdmin(BaseUserAdmin):
    inlines = (UserProfileInline, EmailAddressInline)
    list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff', 'is_faculty_member', 'is_email_verified')
    list_filter = BaseUserAdmin.list_filter + ('groups__name', 'emailaddress__verified')
    actions = ['verify_email_action']
    
    def is_faculty_member(self, obj):
        return obj.groups.filter(name='Faculty').exists()
    is_faculty_member.boolean = True
    is_faculty_member.short_description = 'Faculty'
    
    def is_email_verified(self, obj):
        try:
            return obj.emailaddress_set.first().verified
        except AttributeError:
            return False
    is_email_verified.boolean = True
    is_email_verified.short_description = 'Email Verified'
    
    def verify_email_action(self, request, queryset):
        verified_count = 0
        for user in queryset:
            email_address, created = EmailAddress.objects.get_or_create(
                user=user,
                email=user.email,
                defaults={'verified': True, 'primary': True}
            )
            
            if not created and not email_address.verified:
                email_address.verified = True
                email_address.save()
                verified_count += 1

        self.message_user(
            request,
            f"Successfully verified email for {verified_count} users.",
            messages.SUCCESS
        )
    verify_email_action.short_description = "Verify email for selected users"

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)

@admin.register(Project)
class ProjectAdmin(admin.ModelAdmin):
    list_display = [
        'title', 'author_link', 'created_at', 'claps_count',
        'comments_count', 'ratings_count', 'github_link_display'
    ]
    list_filter = ['created_at', 'author', 'tags']
    search_fields = ['title', 'description', 'author__username', 'tags']
    readonly_fields = ['created_at', 'updated_at', 'slug', 'claps']
    date_hierarchy = 'created_at'
    
    fieldsets = (
        ('Project Information', {
            'fields': ('title', 'slug', 'description', 'github_link', 'tags')
        }),
        ('Author Information', {
            'fields': ('author',)
        }),
        ('Metrics', {
            'fields': ('claps',)
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def author_link(self, obj):
        url = reverse('admin:auth_user_change', args=[obj.author.id])
        return format_html('<a href="{}">{}</a>', url, obj.author.username)
    author_link.short_description = 'Author'
    
    def claps_count(self, obj):
        return obj.claps
    claps_count.short_description = 'Claps'
    
    def comments_count(self, obj):
        count = obj.comments.count()
        url = reverse('admin:projects_comment_changelist')
        return format_html('<a href="{}?project__id={}">{}</a>', url, obj.id, count)
    comments_count.short_description = 'Comments'
    
    def ratings_count(self, obj):
        count = obj.ratings.count()
        url = reverse('admin:projects_rating_changelist')
        return format_html('<a href="{}?project__id={}">{}</a>', url, obj.id, count)
    ratings_count.short_description = 'Ratings'
    
    def github_link_display(self, obj):
        return format_html('<a href="{}" target="_blank">{}</a>', 
                         obj.github_link, obj.github_link)
    github_link_display.short_description = 'GitHub Repository'

@admin.register(Comment)
class CommentAdmin(admin.ModelAdmin):
    list_display = [
        'user_link', 'project_link', 'parent_comment',
        'created_at', 'content_preview', 'has_replies'
    ]
    list_filter = ['created_at', 'user', 'project']
    search_fields = ['content', 'user__username', 'project__title']
    readonly_fields = ['created_at', 'updated_at']
    date_hierarchy = 'created_at'
    
    def user_link(self, obj):
        url = reverse('admin:auth_user_change', args=[obj.user.id])
        return format_html('<a href="{}">{}</a>', url, obj.user.username)
    user_link.short_description = 'User'
    
    def project_link(self, obj):
        url = reverse('admin:projects_project_change', args=[obj.project.id])
        return format_html('<a href="{}">{}</a>', url, obj.project.title)
    project_link.short_description = 'Project'
    
    def parent_comment(self, obj):
        if obj.parent:
            return format_html('Reply to: {}', obj.parent.content[:50])
        return '-'
    parent_comment.short_description = 'Parent Comment'
    
    def content_preview(self, obj):
        return obj.content[:100] + '...' if len(obj.content) > 100 else obj.content
    content_preview.short_description = 'Content'
    
    def has_replies(self, obj):
        count = obj.replies.count()
        if count:
            url = reverse('admin:projects_comment_changelist')
            return format_html('<a href="{}?parent__id={}">{} replies</a>', 
                             url, obj.id, count)
        return 'No replies'
    has_replies.short_description = 'Replies'

@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ('user', 'title', 'department', 'is_faculty_member', 'created_at')
    list_filter = ('department', 'user__groups', 'created_at')
    search_fields = ('user__username', 'user__email', 'title', 'department')
    readonly_fields = ('created_at', 'updated_at')
    
    def is_faculty_member(self, obj):
        return obj.is_faculty
    is_faculty_member.boolean = True
    is_faculty_member.short_description = 'Faculty'

@admin.register(Notification)
class NotificationAdmin(admin.ModelAdmin):
    list_display = [
        'recipient_link', 'sender_link', 'notification_type',
        'is_read', 'created_at', 'message_preview'
    ]
    list_filter = ['notification_type', 'is_read', 'created_at']
    search_fields = [
        'recipient__username', 'sender__username',
        'message', 'project__title'
    ]
    readonly_fields = ['created_at']
    actions = ['mark_as_read', 'mark_as_unread']
    
    def recipient_link(self, obj):
        url = reverse('admin:auth_user_change', args=[obj.recipient.id])
        return format_html('<a href="{}">{}</a>', url, obj.recipient.username)
    recipient_link.short_description = 'Recipient'
    
    def sender_link(self, obj):
        url = reverse('admin:auth_user_change', args=[obj.sender.id])
        return format_html('<a href="{}">{}</a>', url, obj.sender.username)
    sender_link.short_description = 'Sender'
    
    def message_preview(self, obj):
        return obj.message[:100] + '...' if len(obj.message) > 100 else obj.message
    message_preview.short_description = 'Message'
    
    def mark_as_read(self, request, queryset):
        queryset.update(is_read=True)
    mark_as_read.short_description = "Mark selected notifications as read"
    
    def mark_as_unread(self, request, queryset):
        queryset.update(is_read=False)
    mark_as_unread.short_description = "Mark selected notifications as unread"

@admin.register(ProjectAnalytics)
class ProjectAnalyticsAdmin(admin.ModelAdmin):
    list_display = [
        'project_link', 'view_count', 'unique_visitors',
        'github_clicks', 'last_updated'
    ]
    list_filter = ['last_updated']
    readonly_fields = [
        'view_count', 'unique_visitors', 'github_clicks',
        'avg_time_spent', 'direct_traffic', 'social_traffic',
        'search_traffic', 'referral_traffic', 'desktop_visits',
        'mobile_visits', 'tablet_visits', 'chrome_visits',
        'firefox_visits', 'safari_visits', 'edge_visits',
        'other_browsers', 'unique_visitors_weekly',
        'unique_visitors_monthly', 'github_clicks_weekly',
        'github_clicks_monthly', 'last_updated'
    ]
    
    fieldsets = (
        ('Project Information', {
            'fields': ('project',)
        }),
        ('Basic Metrics', {
            'fields': (
                'view_count', 'unique_visitors',
                'github_clicks', 'avg_time_spent'
            )
        }),
        ('Traffic Sources', {
            'fields': (
                'direct_traffic', 'social_traffic',
                'search_traffic', 'referral_traffic'
            ),
            'classes': ('collapse',)
        }),
        ('Device Statistics', {
            'fields': (
                'desktop_visits', 'mobile_visits',
                'tablet_visits'
            ),
            'classes': ('collapse',)
        }),
        ('Browser Statistics', {
            'fields': (
                'chrome_visits', 'firefox_visits',
                'safari_visits', 'edge_visits',
                'other_browsers'
            ),
            'classes': ('collapse',)
        }),
        ('Time-based Metrics', {
            'fields': (
                'unique_visitors_weekly',
                'unique_visitors_monthly',
                'github_clicks_weekly',
                'github_clicks_monthly'
            ),
            'classes': ('collapse',)
        })
    )
    
    def project_link(self, obj):
        url = reverse('admin:projects_project_change', args=[obj.project.id])
        return format_html('<a href="{}">{}</a>', url, obj.project.title)
    project_link.short_description = 'Project'

@admin.register(Follow)
class FollowAdmin(admin.ModelAdmin):
    list_display = ('follower', 'following', 'created_at')
    search_fields = ('follower__username', 'following__username')

class CustomAdminSite(admin.AdminSite):
    site_header = 'KHCC AI Lab Administration'
    site_title = 'KHCC AI Lab Admin'
    index_title = 'Dashboard'
    
    def get_app_list(self, request):
        app_list = super().get_app_list(request)
        
        # Add custom statistics to the admin index
        app_list.append({
            'name': 'Statistics',
            'app_label': 'statistics',
            'models': [
                {
                    'name': 'Total Seeds',
                    'object_name': 'projects',
                    'count': Project.objects.count(),
                    'admin_url': reverse('admin:projects_project_changelist'),
                },
                {
                    'name': 'Total Users',
                    'object_name': 'users',
                    'count': UserProfile.objects.count(),
                    'admin_url': reverse('admin:auth_user_changelist'),
                },
                {
                    'name': 'Total Comments',
                    'object_name': 'comments',
                    'count': Comment.objects.count(),
                    'admin_url': reverse('admin:projects_comment_changelist'),
                },
                {
                    'name': 'Total Claps',
                    'object_name': 'claps',
                    'count': Clap.objects.count(),
                    'admin_url': '#',
                },
            ]
        })
        
        return app_list

# Register the custom admin site
admin_site = CustomAdminSite(name='admin')
admin_site.register(Project, ProjectAdmin)
admin_site.register(Comment, CommentAdmin)
admin_site.register(UserProfile, UserProfileAdmin)
admin_site.register(Notification, NotificationAdmin)
admin_site.register(ProjectAnalytics, ProjectAnalyticsAdmin)
admin_site.register(Follow, FollowAdmin)




# Contents from: .\apps.py
from django.apps import AppConfig


class ProjectsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "projects"

    def ready(self):
        import projects.signals  # Register signals when app is ready


# Contents from: .\context_processors.py
# projects/context_processors.py

from django.conf import settings
from .models import Project, UserProfile

def site_context(request):
    """
    Add common context variables to all templates
    """
    context = {
        'site_name': settings.SITE_NAME,
        'site_url': settings.SITE_URL,
    }
    
    if request.user.is_authenticated:
        # Get unread notifications count
        context['unread_notifications_count'] = request.user.notifications.filter(
            is_read=False
        ).count()
        
        # Get user's bookmarked projects
        context['bookmarked_projects'] = Project.objects.filter(
            bookmarks__user=request.user
        ).values_list('id', flat=True)
        
        # Check if user has completed their profile
        try:
            profile = request.user.profile
            context['profile_completed'] = all([
                profile.bio,
                profile.location,
                profile.avatar
            ])
        except UserProfile.DoesNotExist:
            context['profile_completed'] = False
    
    return context

def notifications_processor(request):
    if request.user.is_authenticated:
        unread_count = request.user.notifications.filter(is_read=False).count()
        recent_notifications = request.user.notifications.all()[:5]
        return {
            'unread_notifications_count': unread_count,
            'notifications': recent_notifications,
        }
    return {}

# Contents from: .\filters\__init__.py
from .project_filters import ProjectFilter

__all__ = ['ProjectFilter']


# Contents from: .\filters\project_filters.py
import django_filters
from django.db.models import Q
from ..models import Project

class ProjectFilter(django_filters.FilterSet):
    """FilterSet for advanced project filtering"""
    query = django_filters.CharFilter(method='filter_query')
    tags = django_filters.CharFilter(method='filter_tags')
    date_from = django_filters.DateFilter(field_name='created_at', lookup_expr='gte')
    date_to = django_filters.DateFilter(field_name='created_at', lookup_expr='lte')
    min_claps = django_filters.NumberFilter(field_name='claps', lookup_expr='gte')
    has_github = django_filters.BooleanFilter(method='filter_has_github')
    
    class Meta:
        model = Project
        fields = ['query', 'tags', 'date_from', 'date_to', 'min_claps', 'has_github']
    
    def filter_query(self, queryset, name, value):
        if not value:
            return queryset
        
        return queryset.filter(
            Q(title__icontains=value) |
            Q(description__icontains=value) |
            Q(author__username__icontains=value) |
            Q(tags__icontains=value)
        )
    
    def filter_tags(self, queryset, name, value):
        if not value:
            return queryset
        
        tags = [tag.strip().lower() for tag in value.split(',') if tag.strip()]
        for tag in tags:
            queryset = queryset.filter(tags__icontains=tag)
        return queryset
    
    def filter_has_github(self, queryset, name, value):
        if value:
            return queryset.exclude(github_link='')
        return queryset

# Contents from: .\forms.py
# projects/forms.py

from django import forms
from django.core.validators import URLValidator, FileExtensionValidator
from django.core.exceptions import ValidationError
from django.db.models import Avg, Count, Q
import mimetypes
from PIL import Image
from io import BytesIO
import os

from django import forms
from .models import (
    Project, Comment, UserProfile, Rating, Bookmark, 
    Notification, Startup, Product, Tool, Dataset,
    VirtualMember, Application, Sponsorship
)

from .models import (
    Project,
    Comment,
    UserProfile,
    Rating,
    Bookmark,
    ProjectAnalytics,
    Notification,
    Solution,
    Team
)

from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User
from khcc_psut_ai_lab.constants import TALENT_TYPES



class NotificationSettingsForm(forms.Form):
    email_on_comment = forms.BooleanField(
        required=False,
        label='Email me when someone comments on my projects',
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    email_on_follow = forms.BooleanField(
        required=False,
        label='Email me when someone follows me',
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    email_on_clap = forms.BooleanField(
        required=False,
        label='Email me when someone clap_count for my projects',
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    email_on_bookmark = forms.BooleanField(
        required=False,
        label='Email me when someone bookmarks my projects',
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )

class ProjectForm(forms.ModelForm):
    """
    Form for creating and editing projects.
    Includes validation for GitHub links and tag formatting.
    """
    tags = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter tags separated by commas (e.g., AI, Machine Learning, NLP)',
            'data-toggle': 'tooltip',
            'title': 'Add up to 5 tags to help others find your project'
        })
    )
    
    class Meta:
        model = Project
        fields = [
            'title', 'description', 'github_link', 'tags',
            'pdf_file', 'featured_image', 'additional_files',
            'youtube_url', 'is_gold', 'token_reward',
            'gold_goal', 'deadline'
        ]
        widgets = {
            'deadline': forms.DateTimeInput(
                attrs={'type': 'datetime-local'},
                format='%Y-%m-%dT%H:%M'
            ),
            'tags': forms.TextInput(
                attrs={'placeholder': 'Enter tags separated by commas'}
            ),
            'gold_goal': forms.Select(
                attrs={'class': 'form-select'}
            ),
        }

    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user', None)
        instance = kwargs.get('instance', None)
        super().__init__(*args, **kwargs)
        
        # Only show gold seed fields to faculty members
        if self.user and not self.user.groups.filter(name='Faculty').exists():
            self.fields.pop('is_gold', None)
            self.fields.pop('token_reward', None)
            self.fields.pop('gold_goal', None)
            self.fields.pop('deadline', None)
        else:
            # Add help text for faculty members
            self.fields['is_gold'].help_text = "Mark this as a Gold Seed to offer tokens for completion"
            self.fields['token_reward'].help_text = "Number of tokens to award for completion"
            self.fields['gold_goal'].help_text = "How tokens will be awarded"
            self.fields['deadline'].help_text = "Deadline for submitting solutions"
            
            # If this is an existing project, format the deadline
            if instance and instance.deadline:
                self.initial['deadline'] = instance.deadline.strftime('%Y-%m-%dT%H:%M')

    def clean_github_link(self):
        """Validate GitHub repository URL"""
        url = self.cleaned_data['github_link']
        if url:  # Only validate if URL is provided
            if not url.startswith(('https://github.com/', 'http://github.com/')):
                raise ValidationError('Please enter a valid GitHub repository URL')
            
            try:
                URLValidator()(url)
            except ValidationError:
                raise ValidationError('Please enter a valid URL')
        
        return url

    def clean_tags(self):
        """Validate and format tags"""
        tags = self.cleaned_data['tags']
        if not tags:
            return ''
        
        tag_list = [tag.strip().lower() for tag in tags.split(',') if tag.strip()]
        seen = set()
        unique_tags = [x for x in tag_list if not (x in seen or seen.add(x))]
        
        if len(unique_tags) > 5:
            raise ValidationError('Please enter no more than 5 unique tags')
        
        if any(len(tag) > 20 for tag in unique_tags):
            raise ValidationError('Each tag must be less than 20 characters')
        
        return ', '.join(unique_tags)

    def clean_pdf_file(self):
        """Validate PDF file"""
        pdf_file = self.cleaned_data.get('pdf_file')
        if pdf_file:
            if pdf_file.size > 10 * 1024 * 1024:
                raise ValidationError('PDF file must be smaller than 10MB')

            ext = os.path.splitext(pdf_file.name)[1].lower()
            if ext != '.pdf':
                raise ValidationError('Only PDF files are allowed')

            file_type, encoding = mimetypes.guess_type(pdf_file.name)
            if file_type != 'application/pdf':
                raise ValidationError('Invalid PDF file')

        return pdf_file

    def clean_featured_image(self):
        """Validate and process featured image"""
        image = self.cleaned_data.get('featured_image')
        if image:
            if image.size > 5 * 1024 * 1024:
                raise ValidationError('Image file must be smaller than 5MB')

            try:
                img = Image.open(image)
                
                if img.mode not in ('RGB', 'RGBA'):
                    img = img.convert('RGB')
                
                if img.width > 2000 or img.height > 2000:
                    raise ValidationError('Image dimensions should not exceed 2000x2000 pixels')
                
                if img.width > 1200 or img.height > 1200:
                    output_size = (1200, 1200)
                    img.thumbnail(output_size, Image.LANCZOS)
                
                output = BytesIO()
                img.save(output, format='JPEG', quality=85, optimize=True)
                output.seek(0)
                
                from django.core.files.uploadedfile import InMemoryUploadedFile
                return InMemoryUploadedFile(
                    output,
                    'ImageField',
                    f"{os.path.splitext(image.name)[0]}.jpg",
                    'image/jpeg',
                    output.tell(),
                    None
                )
            except Exception as e:
                raise ValidationError(f'Invalid image file: {str(e)}')
        return image

class CommentForm(forms.ModelForm):
    """Form for adding comments to projects"""
    class Meta:
        model = Comment
        fields = ['content', 'image']
        widgets = {
            'content': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Write your comment here...'
            }),
            'image': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            })
        }

# Add this class to forms.py

class ProfileForm(forms.ModelForm):
    avatar = forms.ImageField(
        required=False,
        validators=[FileExtensionValidator(allowed_extensions=['jpg', 'jpeg', 'png', 'gif'])],
        widget=forms.FileInput(attrs={
            'class': 'form-control',
            'accept': 'image/*'
        })
    )

    class Meta:
        model = UserProfile
        fields = [
            'avatar',
            'bio',
            'location',
            'website',
            'github_username',
            'linkedin_url',
            'title',
            'department',
            'research_interests',
            
        ]
        widgets = {
            'bio': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Tell us about yourself...'
            }),
            'location': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Where are you based?'
            }),
            'website': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            }),
            'github_username': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Your GitHub username'
            }),
            'linkedin_url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'Your LinkedIn URL'
            })
        }

    def clean_avatar(self):
        avatar = self.cleaned_data.get('avatar')
        if avatar:
            if avatar.size > 5 * 1024 * 1024:  # 5MB limit
                raise forms.ValidationError("Image file too large ( > 5MB )")
        return avatar

class RatingForm(forms.ModelForm):
    """Form for rating projects"""
    class Meta:
        model = Rating
        fields = ['score', 'review']

class BookmarkForm(forms.ModelForm):
    """Form for managing bookmarks"""
    class Meta:
        model = Bookmark
        fields = ['project']
        widgets = {
            'project': forms.HiddenInput()
        }

class ProjectSearchForm(forms.Form):
    """Form for project search and filtering"""
    query = forms.CharField(required=False)
    tags = forms.CharField(required=False)
    sort = forms.ChoiceField(
        required=False,
        choices=[
            ('-created_at', 'Newest first'),
            ('created_at', 'Oldest first'),
            ('-clap_count', 'Most popular'),
            ('title', 'Alphabetical'),
        ]
    )

class AdvancedSearchForm(forms.Form):
    """Advanced search form"""
    query = forms.CharField(required=False)
    tags = forms.CharField(required=False)
    date_from = forms.DateField(required=False)
    date_to = forms.DateField(required=False)
    min_claps = forms.IntegerField(required=False, min_value=0)
    has_github = forms.BooleanField(required=False)
    sort_by = forms.ChoiceField(
        required=False,
        choices=[
            ('-created_at', 'Newest first'),
            ('created_at', 'Oldest first'),
            ('-clap_count', 'Most popular'),
            ('-comment_count', 'Most discussed'),
            ('title', 'Alphabetical'),
            ('-rating_avg', 'Highest rated')
        ]
    )


class FileValidationMixin:
    """Mixin for common file validation methods"""
    
    def validate_file_size(self, file, max_size_mb=5):
        if file.size > max_size_mb * 1024 * 1024:
            raise ValidationError(f'File size must be no more than {max_size_mb}MB')
    
    def validate_file_type(self, file, allowed_types):
        file_type = mimetypes.guess_type(file.name)[0]
        if file_type not in allowed_types:
            raise ValidationError(f'File type {file_type} is not supported')
    
    def validate_image(self, image, max_dimension=2000):
        try:
            img = Image.open(image)
            if img.width > max_dimension or img.height > max_dimension:
                raise ValidationError(f'Image dimensions should not exceed {max_dimension}x{max_dimension} pixels')
            return img
        except Exception as e:
            raise ValidationError(f'Invalid image file: {str(e)}')

class ProjectForm(forms.ModelForm, FileValidationMixin):
    """
    Form for creating and editing projects.
    Includes validation for GitHub links and tag formatting.
    """
    tags = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter tags separated by commas (e.g., AI, Machine Learning, NLP)',
            'data-toggle': 'tooltip',
            'title': 'Add up to 5 tags to help others find your project'
        })
    )
    
    class Meta:
        model = Project
        fields = ['title', 'description', 'github_link', 'tags', 'pdf_file', 'featured_image']
        widgets = {
            'title': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter project title',
                'maxlength': '200'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 5,
                'placeholder': 'Describe your project in detail...'
            }),
            'github_link': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://github.com/username/repository'
            }),
            'pdf_file': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'application/pdf',
            }),
            'featured_image': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*',
            })
        }

    def clean_github_link(self):
        url = self.cleaned_data['github_link']
        if url:  # Only validate if URL is provided
            if not url.startswith(('https://github.com/', 'http://github.com/')):
                raise ValidationError('Please enter a valid GitHub repository URL')
            
            try:
                URLValidator()(url)
            except ValidationError:
                raise ValidationError('Please enter a valid URL')
        
        return url

    def clean_tags(self):
        tags = self.cleaned_data['tags']
        if not tags:
            return ''
        
        tag_list = [tag.strip().lower() for tag in tags.split(',') if tag.strip()]
        seen = set()
        unique_tags = [x for x in tag_list if not (x in seen or seen.add(x))]
        
        if len(unique_tags) > 5:
            raise ValidationError('Please enter no more than 5 unique tags')
        
        if any(len(tag) > 20 for tag in unique_tags):
            raise ValidationError('Each tag must be less than 20 characters')
        
        return ', '.join(unique_tags)

    def clean_pdf_file(self):
        pdf_file = self.cleaned_data.get('pdf_file')
        if pdf_file:
            self.validate_file_size(pdf_file, 10)
            self.validate_file_type(pdf_file, ['application/pdf'])
        return pdf_file

    def clean_featured_image(self):
        image = self.cleaned_data.get('featured_image')
        if image:
            self.validate_file_size(image, 5)
            img = self.validate_image(image)
            
            if img.mode not in ('RGB', 'RGBA'):
                img = img.convert('RGB')
            
            if img.width > 1200 or img.height > 1200:
                output_size = (1200, 1200)
                img.thumbnail(output_size, Image.LANCZOS)
            
            output = BytesIO()
            img.save(output, format='JPEG', quality=85, optimize=True)
            output.seek(0)
            
            from django.core.files.uploadedfile import InMemoryUploadedFile
            return InMemoryUploadedFile(
                output,
                'ImageField',
                f"{os.path.splitext(image.name)[0]}.jpg",
                'image/jpeg',
                output.tell(),
                None
            )
        return image

class CommentForm(forms.ModelForm, FileValidationMixin):
    """Form for adding comments to projects"""
    class Meta:
        model = Comment
        fields = ['content', 'image']
        widgets = {
            'content': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Write your comment here...'
            }),
            'image': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            })
        }

    def clean_content(self):
        content = self.cleaned_data['content'].strip()
        if len(content) < 10:
            raise ValidationError('Comment must be at least 10 characters long')
        if len(content) > 1000:
            raise ValidationError('Comment must be less than 1000 characters')
        return content

    def clean_image(self):
        image = self.cleaned_data.get('image')
        if image:
            self.validate_file_size(image, 2)
            img = self.validate_image(image, 1000)
            
            if img.mode not in ('RGB', 'RGBA'):
                img = img.convert('RGB')
            
            if img.width > 800 or img.height > 800:
                output_size = (800, 800)
                img.thumbnail(output_size, Image.LANCZOS)
            
            output = BytesIO()
            img.save(output, format='JPEG', quality=85, optimize=True)
            output.seek(0)
            
            from django.core.files.uploadedfile import InMemoryUploadedFile
            return InMemoryUploadedFile(
                output,
                'ImageField',
                f"{os.path.splitext(image.name)[0]}.jpg",
                'image/jpeg',
                output.tell(),
                None
            )
        return image

class UserProfileForm(forms.ModelForm, FileValidationMixin):
    """Form for user profile management"""
    class Meta:
        model = UserProfile
        fields = [
            'bio', 'location', 'website', 'github_username',
            'linkedin_url', 'avatar', 'email_on_comment',
            'email_on_follow', 'email_on_clap', 'email_on_bookmark'
        ]
        widgets = {
            'bio': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Tell us about yourself...'
            }),
            'location': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Where are you based?'
            }),
            'website': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://yourwebsite.com'
            }),
            'github_username': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Your GitHub username'
            }),
            'linkedin_url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://linkedin.com/in/your-profile'
            }),
            'avatar': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            })
        }

    def clean_avatar(self):
        avatar = self.cleaned_data.get('avatar')
        if avatar:
            self.validate_file_size(avatar, 5)
            img = self.validate_image(avatar)
            
            if img.mode not in ('RGB', 'RGBA'):
                img = img.convert('RGB')
            
            output_size = (300, 300)
            img.thumbnail(output_size, Image.LANCZOS)
            
            output = BytesIO()
            img.save(output, format='JPEG', quality=85, optimize=True)
            output.seek(0)
            
            from django.core.files.uploadedfile import InMemoryUploadedFile
            return InMemoryUploadedFile(
                output,
                'ImageField',
                f"{os.path.splitext(avatar.name)[0]}.jpg",
                'image/jpeg',
                output.tell(),
                None
            )
        return avatar

class RatingForm(forms.ModelForm):
    """Form for rating projects"""
    class Meta:
        model = Rating
        fields = ['score', 'review']
        widgets = {
            'score': forms.Select(attrs={
                'class': 'form-select'
            }),
            'review': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Write your review here...'
            })
        }

class BookmarkForm(forms.ModelForm):
    """Form for managing bookmarks"""
    class Meta:
        model = Bookmark
        fields = ['project']
        widgets = {
            'project': forms.HiddenInput()
        }

class NotificationSettingsForm(forms.Form):
    """Form for notification preferences"""
    email_on_comment = forms.BooleanField(
        required=False,
        label='Email me when someone comments on my projects'
    )
    email_on_follow = forms.BooleanField(
        required=False,
        label='Email me when someone follows me'
    )
    email_on_clap = forms.BooleanField(
        required=False,
        label='Email me when someone clap_count for my projects'
    )
    email_on_bookmark = forms.BooleanField(
        required=False,
        label='Email me when someone bookmarks my projects'
    )

class ProjectSearchForm(forms.Form):
    """Form for project search and filtering"""
    query = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Search seeds...'
        })
    )
    
    tags = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Filter by tags (comma separated)'
        })
    )
    
    sort = forms.ChoiceField(
        required=False,
        choices=[
            ('-created_at', 'Newest first'),
            ('created_at', 'Oldest first'),
            ('-clap_count', 'Most popular'),
            ('title', 'Alphabetical'),
        ],
        widget=forms.Select(attrs={
            'class': 'form-select'
        })
    )

class AdvancedSearchForm(forms.Form):
    """Advanced search form with multiple filters"""
    query = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Search by title, description, or author'
        })
    )
    
    tags = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'data-role': 'tagsinput'
        })
    )
    
    date_from = forms.DateField(
        required=False,
        widget=forms.DateInput(attrs={
            'class': 'form-control',
            'type': 'date'
        })
    )
    
    date_to = forms.DateField(
        required=False,
        widget=forms.DateInput(attrs={
            'class': 'form-control',
            'type': 'date'
        })
    )
    
    min_claps = forms.IntegerField(
        required=False,
        min_value=0,
        widget=forms.NumberInput(attrs={'class': 'form-control'})
    )
    
    has_github = forms.BooleanField(
        required=False,
        initial=False,
        widget=forms.CheckboxInput(attrs={'class': 'form-check-input'})
    )
    
    sort_by = forms.ChoiceField(
        required=False,
        choices=[
            ('-created_at', 'Newest first'),
            ('created_at', 'Oldest first'),
            ('-clap_count', 'Most popular'),
            ('-comment_count', 'Most discussed'),
            ('title', 'Alphabetical'),
            ('-rating_avg', 'Highest rated')
        ],
        widget=forms.Select(attrs={'class': 'form-select'})
    )

    def clean(self):
        cleaned_data = super().clean()
        date_from = cleaned_data.get('date_from')
        date_to = cleaned_data.get('date_to')
        
        if date_from and date_to and date_from > date_to:
            raise ValidationError("End date should be greater than start date")
        
        return cleaned_data
    

# In forms.py
from django import forms
from .models import Project, Comment
from django.core.validators import FileExtensionValidator
from django.core.exceptions import ValidationError
from PIL import Image
from io import BytesIO
import os

class ProjectForm(forms.ModelForm):
    """Form for creating and editing projects."""
    tags = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter tags separated by commas (e.g., AI, Machine Learning, NLP)',
            'data-toggle': 'tooltip',
            'title': 'Add up to 5 tags to help others find your project'
        })
    )
    
    class Meta:
        model = Project
        fields = ['title', 'description', 'github_link', 'tags', 'youtube_url', 
                 'pdf_file', 'featured_image', 'additional_files']
        
    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop('user', None)
        super().__init__(*args, **kwargs)
        
        # Only show gold seed fields to faculty members
        if self.user and self.user.groups.filter(name='Faculty').exists():
            self.fields['is_gold'] = forms.BooleanField(required=False)
            self.fields['token_reward'] = forms.IntegerField(required=False)
            self.fields['gold_goal'] = forms.ChoiceField(
                choices=[
                    ('all', 'All Complete'),
                    ('first', 'First to Complete'),
                    ('best', 'Best Solution')
                ],
                required=False
            )
            self.fields['deadline'] = forms.DateTimeField(
                required=False,
                widget=forms.DateTimeInput(attrs={'type': 'datetime-local'})
            )
        
    def clean_youtube_url(self):
        url = self.cleaned_data.get('youtube_url')
        if url:
            from .models import validate_youtube_url
            validate_youtube_url(url)
        return url

    def clean_pdf_file(self):
        pdf_file = self.cleaned_data.get('pdf_file')
        if pdf_file and pdf_file.size > 10 * 1024 * 1024:  # 10MB limit
            raise ValidationError('PDF file must be smaller than 10MB')
        return pdf_file

    def clean_featured_image(self):
        image = self.cleaned_data.get('featured_image')
        if image:
            if image.size > 5 * 1024 * 1024:  # 5MB limit
                raise ValidationError('Image file must be smaller than 5MB')
            try:
                img = Image.open(image)
                if img.mode not in ('RGB', 'RGBA'):
                    img = img.convert('RGB')
                
                # Resize if needed
                if img.width > 1200 or img.height > 1200:
                    output_size = (1200, 1200)
                    img.thumbnail(output_size, Image.LANCZOS)
                
                output = BytesIO()
                img.save(output, format='JPEG', quality=85)
                output.seek(0)
                
                from django.core.files.uploadedfile import InMemoryUploadedFile
                return InMemoryUploadedFile(
                    output,
                    'ImageField',
                    f"{os.path.splitext(image.name)[0]}.jpg",
                    'image/jpeg',
                    output.tell(),
                    None
                )
            except Exception as e:
                raise ValidationError(f'Invalid image file: {str(e)}')
        return image

class ExtendedUserCreationForm(UserCreationForm):
    talent_type = forms.ChoiceField(
        choices=TALENT_TYPES,
        required=True,
        label='Select Your Talent Type',
        widget=forms.Select(attrs={'class': 'form-select'})
    )

    class Meta:
        model = User
        fields = ('username', 'email', 'password1', 'password2', 'talent_type')

    def save(self, commit=True):
        user = super().save(commit=False)
        if commit:
            user.save()
            UserProfile.objects.create(
                user=user,
                talent_type=self.cleaned_data['talent_type']
            )
        return user

class SolutionForm(forms.ModelForm):
    class Meta:
        model = Solution
        fields = ['content', 'files', 'github_link']

from django import forms
from .models import Team, TeamDiscussion, TeamComment, TeamMembership

class TeamForm(forms.ModelForm):
    class Meta:
        model = Team
        fields = ['name', 'description', 'tags', 'team_image']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter team name'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your team and its goals'
            }),
            'tags': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter tags separated by commas (e.g., AI, Healthcare, Research)'
            }),
            'team_image': forms.FileInput(attrs={
                'class': 'form-control'
            })
        }

    def clean_name(self):
        name = self.cleaned_data['name']
        if self.instance.pk:
            if Team.objects.exclude(pk=self.instance.pk).filter(name__iexact=name).exists():
                raise forms.ValidationError('A team with this name already exists.')
        else:
            if Team.objects.filter(name__iexact=name).exists():
                raise forms.ValidationError('A team with this name already exists.')
        return name

class TeamDiscussionForm(forms.ModelForm):
    class Meta:
        model = TeamDiscussion
        fields = ['title', 'content']
        widgets = {
            'content': forms.Textarea(attrs={'rows': 6})
        }

class TeamCommentForm(forms.ModelForm):
    class Meta:
        model = TeamComment
        fields = ['content']
        widgets = {
            'content': forms.Textarea(attrs={'rows': 3})
        }

class TeamMembershipForm(forms.ModelForm):
    class Meta:
        model = TeamMembership
        fields = ['role', 'is_approved']
        widgets = {
            'role': forms.Select(attrs={'class': 'form-select'}),
            'is_approved': forms.CheckboxInput(attrs={'class': 'form-check-input'})
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Only allow certain role choices based on permissions
        user = kwargs.get('initial', {}).get('user')
        if user and not user.is_staff:
            self.fields['role'].choices = [
                ('member', 'Member'),
                ('moderator', 'Moderator')
            ]

class TeamNotificationSettingsForm(forms.Form):
    email_notifications = forms.BooleanField(required=False)
    in_app_notifications = forms.BooleanField(required=False)

class TeamForm(forms.ModelForm):
    class Meta:
        model = Team
        fields = ['name', 'description', 'tags', 'team_image']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
            'tags': forms.TextInput(attrs={
                'placeholder': 'Enter tags separated by commas'
            }),
        }
    
    def clean_name(self):
        name = self.cleaned_data['name']
        if Team.objects.filter(name__iexact=name).exists():
            raise forms.ValidationError('A team with this name already exists.')
        return name
    
    def clean_tags(self):
        tags = self.cleaned_data['tags']
        if tags:
            # Split tags by comma and clean them
            tag_list = [tag.strip() for tag in tags.split(',') if tag.strip()]
            # Rejoin cleaned tags
            return ', '.join(tag_list)
        return tags

# forms.py additions




class StartupForm(forms.ModelForm):
    class Meta:
        model = Startup
        fields = ['name', 'logo', 'description', 'website']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter startup name'
            }),
            'logo': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your startup'
            }),
            'website': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            })
        }

    def clean_logo(self):
        logo = self.cleaned_data.get('logo')
        if logo:
            if logo.size > 5 * 1024 * 1024:  # 5MB limit
                raise forms.ValidationError("Image file too large ( > 5MB )")
            return logo
        return None

class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        fields = ['name', 'description', 'image', 'url']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter product name'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your product'
            }),
            'image': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            })
        }

class ToolForm(forms.ModelForm):
    class Meta:
        model = Tool
        fields = ['name', 'description', 'image', 'url', 'github_url', 'documentation_url']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter tool name'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your tool'
            }),
            'image': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            }),
            'github_url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://github.com/...'
            }),
            'documentation_url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            })
        }

class DatasetForm(forms.ModelForm):
    class Meta:
        model = Dataset
        fields = ['name', 'description', 'file', 'format', 'license']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter dataset name'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your dataset'
            }),
            'file': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': '.zip,.csv,.json,.txt'
            }),
            'format': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'e.g., CSV, JSON, etc.'
            }),
            'license': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'e.g., MIT, Apache, etc.'
            })
        }

    def clean_file(self):
        file = self.cleaned_data.get('file')
        if file:
            if file.size > 50 * 1024 * 1024:  # 50MB limit
                raise forms.ValidationError("File too large ( > 50MB )")
        return file

class SponsorshipForm(forms.ModelForm):
    class Meta:
        model = Sponsorship
        fields = ['name', 'logo', 'level', 'website', 'description']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Organization name'
            }),
            'logo': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'level': forms.Select(attrs={
                'class': 'form-select'
            }),
            'website': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe your organization'
            })
        }

class VirtualMemberForm(forms.ModelForm):
    class Meta:
        model = VirtualMember
        fields = ['name', 'avatar', 'specialty', 'description']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Virtual member name'
            }),
            'avatar': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'specialty': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Area of expertise'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 4,
                'placeholder': 'Describe this virtual member'
            })
        }

class ApplicationForm(forms.ModelForm):
    class Meta:
        model = Application
        fields = [
            'type',
            'name',
            'email',
            'organization',
            'level',
            'message',
            'attachment'
        ]
        widgets = {
            'type': forms.HiddenInput(),
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Your full name'
            }),
            'email': forms.EmailInput(attrs={
                'class': 'form-control',
                'placeholder': 'Your email address'
            }),
            'organization': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Organization name'
            }),
            'level': forms.Select(attrs={
                'class': 'form-control'
            }),
            'message': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 5,
                'placeholder': 'Tell us about yourself or your organization'
            }),
            'attachment': forms.FileInput(attrs={
                'class': 'form-control'
            })
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Make certain fields optional
        self.fields['organization'].required = False
        self.fields['level'].required = False
        self.fields['attachment'].required = False

# Contents from: .\models.py
# projects/models.py

from django.db import models
from django.contrib.auth.models import User
from django.core.validators import URLValidator, FileExtensionValidator
from django.core.exceptions import ValidationError
from django.utils.text import slugify
from datetime import timedelta
import os
from django.db.models.signals import post_save
from django.dispatch import receiver
import uuid
from django.db.models import Avg
from django.conf import settings
from khcc_psut_ai_lab.constants import TALENT_TYPES
from django.utils import timezone

# Add these constants
gold_goalS = [
    ('all', 'All Complete'),
    ('first', 'First to Complete'),
    ('best', 'Best Solution')
]

# File Upload Path Functions
def validate_github_url(value):
    if not value.startswith(('https://github.com/', 'http://github.com/')):
        raise ValidationError('URL must be a GitHub repository')

def project_file_upload_path(instance, filename):
    """Generate upload path for project files"""
    return f'uploads/user_{instance.author.id}/project_{instance.pk}/{filename}'

def project_image_upload_path(instance, filename):
    """Generate upload path for project images"""
    return f'images/projects/user_{instance.author.id}/{filename}'

def avatar_upload_path(instance, filename):
    """Generate upload path for user avatars"""
    return f'avatars/user_{instance.user.id}/{filename}'

def comment_image_upload_path(instance, filename):
    """Generate upload path for comment images"""
    return f'images/comments/user_{instance.user.id}/{filename}'

# Add to models.py
from urllib.parse import urlparse, parse_qs

def validate_youtube_url(url):
    if not url:
        return
    
    try:
        parsed = urlparse(url)
        if parsed.hostname not in ['www.youtube.com', 'youtube.com', 'youtu.be']:
            raise ValidationError('Only YouTube URLs are allowed')
            
        if parsed.hostname in ['youtube.com', 'www.youtube.com']:
            if not parsed.path.startswith('/watch'):
                raise ValidationError('Invalid YouTube URL format')
            if not parse_qs(parsed.query).get('v'):
                raise ValidationError('Invalid YouTube URL format')
        elif parsed.hostname == 'youtu.be':
            if not parsed.path[1:]:
                raise ValidationError('Invalid YouTube URL format')
    except Exception:
        raise ValidationError('Invalid YouTube URL')
    
class VirtualMember(models.Model):
    name = models.CharField(max_length=100)
    avatar = models.ImageField(upload_to='virtual_members/')
    specialty = models.CharField(max_length=100)
    description = models.TextField()
    projects = models.ManyToManyField('Project', related_name='virtual_team_members')

    def __str__(self):
        return self.name

class Startup(models.Model):
    name = models.CharField(max_length=200)
    logo = models.ImageField(upload_to='startup_logos/')
    description = models.TextField()
    website = models.URLField()
    founder = models.ForeignKey(User, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    products = models.ManyToManyField('Product', related_name='startups')    
# Models
class Project(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True, max_length=255, blank=True)
    description = models.TextField()
    github_link = models.URLField(validators=[URLValidator(), validate_github_url], blank=True, null=True)
    tags = models.CharField(
        max_length=100, 
        blank=True, 
        help_text="Enter tags separated by commas"
    )
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    clap_count = models.IntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_featured = models.BooleanField(default=False)
    virtual_members = models.ManyToManyField(VirtualMember, related_name='assigned_projects')
    generated_tags = models.TextField(blank=True)  # AI-generated tags
    
    # File fields
    pdf_file = models.FileField(
        upload_to=project_file_upload_path,
        validators=[FileExtensionValidator(allowed_extensions=['pdf'])],
        null=True,
        blank=True,
        help_text="Upload a PDF document (max 10MB)"
    )
    
    featured_image = models.ImageField(
        upload_to=project_image_upload_path,
        null=True,
        blank=True,
        help_text="Upload a featured image for your project"
    )
    
    additional_files = models.FileField(
        upload_to=project_file_upload_path,
        validators=[
            FileExtensionValidator(
                allowed_extensions=['pdf', 'doc', 'docx', 'txt', 'zip']
            )
        ],
        null=True,
        blank=True,
        help_text="Upload additional files (PDF, DOC, TXT, ZIP - max 10MB)"
    )
    
    rating_total = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    rating_count = models.PositiveIntegerField(default=0)

    youtube_url = models.URLField(
        validators=[validate_youtube_url],
        blank=True,
        null=True,
        help_text="Link to a YouTube video for your project"
    )
    
    # New fields for Gold Seeds
    is_gold = models.BooleanField(default=False, help_text="Mark this as a Gold Seed (Faculty only)")
    token_reward = models.PositiveIntegerField(
        null=True, 
        blank=True, 
        help_text="Number of tokens awarded for completion"
    )
    gold_goal = models.CharField(
        max_length=10,
        choices=gold_goalS,
        null=True,
        blank=True
    )
    deadline = models.DateTimeField(null=True, blank=True)
    is_completed = models.BooleanField(default=False)

    def get_youtube_embed_url(self):
        """Convert YouTube video URL to embed URL"""
        if not self.youtube_url:
            return None
            
        video_id = None
        parsed = urlparse(self.youtube_url)
        
        if 'youtube.com' in parsed.hostname:
            query = parse_qs(parsed.query)
            video_id = query.get('v', [None])[0]
        elif 'youtu.be' in parsed.hostname:
            video_id = parsed.path.lstrip('/')
            
        if video_id:
            return f"https://www.youtube.com/embed/{video_id}"
        return None
    
    class Meta:
        ordering = ['-created_at']
        
    def __str__(self):
        return self.title
        
    def save(self, *args, **kwargs):
        if not self.slug:
            # Generate base slug from title
            base_slug = slugify(self.title)
            
            # Check if the base slug exists
            if Project.objects.filter(slug=base_slug).exists():
                # If it exists, append a UUID to make it unique
                base_slug = f"{base_slug}-{str(uuid.uuid4())[:8]}"
            
            self.slug = base_slug
            
        super().save(*args, **kwargs)
    


    @property
    def comment_count(self):
        """Get total number of comments"""
        return self.comments.count()
    
    @property
    def tag_list(self):
        return [tag.strip() for tag in self.tags.split(',') if tag.strip()]

    def user_has_clapped(self, user):
        return self.claps.filter(user=user).exists()
    
    @property
    def average_rating(self):
        if self.rating_count == 0:
            return 0
        return round(float(self.rating_total) / self.rating_count, 1)

    
    def generate_zip(self):
        """Generate a ZIP file of the project"""
        zip_filename = f"{self.slug}_project.zip"
        zip_path = os.path.join(settings.MEDIA_ROOT, 'project_zips', zip_filename)
        
        with zipfile.ZipFile(zip_path, 'w') as zip_file:
            if self.pdf_file:
                zip_file.write(self.pdf_file.path, os.path.basename(self.pdf_file.name))
            if self.additional_files:
                zip_file.write(self.additional_files.path, os.path.basename(self.additional_files.name))
            
            # Add README with project info
            readme_content = f"""
            Project: {self.title}
            Author: {self.author.username}
            Description: {self.description}
            Tags: {self.tags}
            Created: {self.created_at}
            """
            zip_file.writestr('README.txt', readme_content)
        
        return zip_path
    
    
    def clean(self):
        super().clean()
        # Validate file sizes
        if self.pdf_file and self.pdf_file.size > 10 * 1024 * 1024:  # 10MB
            raise ValidationError({'pdf_file': 'PDF file must be smaller than 10MB'})
        if self.additional_files and self.additional_files.size > 10 * 1024 * 1024:
            raise ValidationError({'additional_files': 'File must be smaller than 10MB'})
        if self.featured_image and self.featured_image.size > 5 * 1024 * 1024:  # 5MB
            raise ValidationError({'featured_image': 'Image must be smaller than 5MB'})

    def update_rating_stats(self):
        """Update the rating statistics"""
        ratings = self.ratings.all()
        count = ratings.count()
        if count > 0:
            total = sum(r.score for r in ratings)
            self.rating_total = total
            self.rating_count = count
        else:
            self.rating_total = 0
            self.rating_count = 0
        self.save()

    def get_featured_image_url(self):
        """Get the featured image URL or return None"""
        return self.featured_image.url if self.featured_image else None
        
    def get_pdf_url(self):
        """Get the PDF file URL or return None"""
        return self.pdf_file.url if self.pdf_file else None

    def can_submit(self):
        if not self.is_gold or not self.deadline:
            return False
        return timezone.now() <= self.deadline

class Application(models.Model):
    APPLICATION_TYPES = [
        ('sponsor', 'Sponsor'),
        ('team', 'Team Member'),
    ]
    
    LEVEL_CHOICES = [
        ('bronze', 'Bronze'),
        ('silver', 'Silver'),
        ('gold', 'Gold'),
        ('platinum', 'Platinum'),
    ]

    type = models.CharField(max_length=20, choices=APPLICATION_TYPES)
    name = models.CharField(max_length=200)
    email = models.EmailField()
    organization = models.CharField(max_length=200, blank=True, null=True)
    level = models.CharField(max_length=20, choices=LEVEL_CHOICES, blank=True, null=True)
    message = models.TextField(help_text="Tell us about yourself or your organization")
    attachment = models.FileField(
        upload_to='applications/',
        help_text="PDF format preferred, max 10MB",
        blank=True,
        null=True
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.name} - {self.get_type_display()}"

class Comment(models.Model):
    project = models.ForeignKey(
        Project, 
        related_name='comments', 
        on_delete=models.CASCADE
    )
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    parent = models.ForeignKey(
        'self',
        null=True,
        blank=True,
        related_name='replies',
        on_delete=models.CASCADE
    )
    content = models.TextField()
    image = models.ImageField(
        upload_to=comment_image_upload_path,
        null=True,
        blank=True,
        help_text="Upload an image (optional)"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    clap_count = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['created_at']
    
    def user_has_clapped(self, user):
        return self.claps.filter(user=user).exists()
    
    def __str__(self):
        return f'Comment by {self.user.username} on {self.project.title}'


    
class UserProfile(models.Model):
    user = models.OneToOneField(
        User, 
        on_delete=models.CASCADE, 
        related_name='profile'
    )
    bio = models.TextField(max_length=500, blank=True)
    location = models.CharField(max_length=100, blank=True)
    website = models.URLField(blank=True)
    github_username = models.CharField(max_length=39, blank=True) 
    linkedin_url = models.URLField(blank=True)
    twitter_username = models.CharField(max_length=100, blank=True)
    avatar = models.ImageField(
        upload_to=avatar_upload_path,
        null=True,
        blank=True
    )
    title = models.CharField(max_length=100, blank=True)
    department = models.CharField(max_length=100, blank=True)
    research_interests = models.TextField(blank=True)
    talent_type = models.CharField(
        max_length=20,
        choices=TALENT_TYPES,
        default='ai',
        verbose_name='Talent Type'
    )
    
    
    @property
    def is_faculty(self):
        return self.user.groups.filter(name='Faculty').exists()
    
    # Notification settings
    email_on_comment = models.BooleanField(default=True)
    email_on_follow = models.BooleanField(default=True)
    email_on_clap = models.BooleanField(default=False)
    email_on_bookmark = models.BooleanField(default=False)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.user.username}'s profile"

    def get_talent_display(self):
        return dict(TALENT_TYPES).get(self.talent_type, '')

class Clap(models.Model):
    project = models.ForeignKey(
        Project, 
        related_name='claps', 
        on_delete=models.CASCADE
    )
    user = models.ForeignKey(
        User,
        related_name='user_claps', 
        on_delete=models.CASCADE
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ('project', 'user')
    
    def __str__(self):
        return f'{self.user.username} clapped for {self.project.title}'

class Rating(models.Model):
    RATING_CHOICES = (
        (1, '1 - Poor'),
        (2, '2 - Fair'),
        (3, '3 - Good'),
        (4, '4 - Very Good'),
        (5, '5 - Excellent')
    )
    
    project = models.ForeignKey(
        Project, 
        related_name='ratings', 
        on_delete=models.CASCADE
    )
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    score = models.IntegerField(choices=RATING_CHOICES)
    review = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        unique_together = ('project', 'user')
        
    def __str__(self):
        return f"{self.user.username}'s {self.score}-star rating on {self.project.title}"

class Bookmark(models.Model):
    user = models.ForeignKey(
        User, 
        related_name='bookmarks', 
        on_delete=models.CASCADE
    )
    project = models.ForeignKey(
        Project, 
        related_name='bookmarks', 
        on_delete=models.CASCADE
    )
    created_at = models.DateTimeField(auto_now_add=True)
    notes = models.TextField(blank=True)
    
    class Meta:
        unique_together = ('user', 'project')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.username} bookmarked {self.project.title}"

class ProjectAnalytics(models.Model):
    project = models.OneToOneField(
        Project, 
        on_delete=models.CASCADE, 
        related_name='analytics'
    )
    view_count = models.PositiveIntegerField(default=0)
    unique_visitors = models.PositiveIntegerField(default=0)
    github_clicks = models.PositiveIntegerField(default=0)
    avg_time_spent = models.DurationField(default=timedelta)
    last_updated = models.DateTimeField(auto_now=True)
    
    # Traffic sources
    direct_traffic = models.PositiveIntegerField(default=0)
    social_traffic = models.PositiveIntegerField(default=0)
    search_traffic = models.PositiveIntegerField(default=0)
    referral_traffic = models.PositiveIntegerField(default=0)
    
    # Device stats
    desktop_visits = models.PositiveIntegerField(default=0)
    mobile_visits = models.PositiveIntegerField(default=0)
    tablet_visits = models.PositiveIntegerField(default=0)
    
    # Browser stats
    chrome_visits = models.PositiveIntegerField(default=0)
    firefox_visits = models.PositiveIntegerField(default=0)
    safari_visits = models.PositiveIntegerField(default=0)
    edge_visits = models.PositiveIntegerField(default=0)
    other_browsers = models.PositiveIntegerField(default=0)
    
    # Weekly and monthly stats
    unique_visitors_weekly = models.PositiveIntegerField(default=0)
    unique_visitors_monthly = models.PositiveIntegerField(default=0)
    github_clicks_weekly = models.PositiveIntegerField(default=0)
    github_clicks_monthly = models.PositiveIntegerField(default=0)
    
    class Meta:
        verbose_name_plural = "Project analytics"
        
    def __str__(self):
        return f"Analytics for {self.project.title}"

class Notification(models.Model):
    NOTIFICATION_TYPES = (
        ('comment', 'Comment'),
        ('follow', 'Follow'),
        ('clap', 'Clap'),
        ('bookmark', 'Bookmark'),
    )
    
    recipient = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications')
    sender = models.ForeignKey(User, on_delete=models.CASCADE)
    notification_type = models.CharField(max_length=20, choices=NOTIFICATION_TYPES)
    project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    message = models.TextField()
    is_read = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f'Notification for {self.recipient.username}'

    @classmethod
    def create(cls, recipient, sender, notification_type, project=None, message=None):
        if not message:
            message = cls.get_default_message(notification_type, sender, project)
        return cls.objects.create(
            recipient=recipient,
            sender=sender,
            notification_type=notification_type,
            project=project,
            message=message
        )

    @staticmethod
    def get_default_message(notification_type, sender, project=None):
        username = sender.username
        if project:
            project_title = project.title
            if notification_type == 'clap':
                return f"{username} clapped for your project '{project_title}'"
            elif notification_type == 'comment':
                return f"{username} commented on your project '{project_title}'"
            elif notification_type == 'rating':
                return f"{username} rated your project '{project_title}'"
            elif notification_type == 'bookmark':
                return f"{username} bookmarked your project '{project_title}'"
        elif notification_type == 'follow':
            return f"{username} started following you"
        return "You have a new notification"

class Follow(models.Model):
    follower = models.ForeignKey(
        User, 
        related_name='following',  # User.following.all() gets all users this user follows
        on_delete=models.CASCADE
    )
    following = models.ForeignKey(
        User, 
        related_name='followers',  # User.followers.all() gets all users following this user
        on_delete=models.CASCADE
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ('follower', 'following')
    
    def __str__(self):
        return f'{self.follower.username} follows {self.following.username}'

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)

class CommentClap(models.Model):
    comment = models.ForeignKey(Comment, related_name='claps', on_delete=models.CASCADE)
    user = models.ForeignKey(User, related_name='comment_claps', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ('comment', 'user')

    def __str__(self):
        return f'{self.user.username} clapped for comment on {self.comment.project.title}'
    

class Solution(models.Model):
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name='solutions')
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    files = models.FileField(
        upload_to='solutions/',
        null=True,
        blank=True,
        validators=[FileExtensionValidator(
            allowed_extensions=['pdf', 'doc', 'docx', 'zip', 'py', 'ipynb', 'txt']
        )]
    )
    github_link = models.URLField(blank=True, null=True)
    submitted_at = models.DateTimeField(auto_now_add=True)
    is_approved = models.BooleanField(default=False)
    faculty_feedback = models.TextField(blank=True)
    tokens_awarded = models.PositiveIntegerField(null=True, blank=True)

    class Meta:
        unique_together = ['project', 'user']

    def __str__(self):
        return f"Solution by {self.user.username} for {self.project.title}"



from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MaxValueValidator
from django.urls import reverse
from django.utils.text import slugify
from khcc_psut_ai_lab.constants import DEFAULT_TEAM_SIZE, MAX_TEAM_SIZE, TEAM_ROLES
import uuid

def team_image_upload_path(instance, filename):
    # Generate path like: team_images/team_slug/filename
    return f'team_images/{instance.slug}/{filename}'

class Team(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, max_length=100, blank=True)
    description = models.TextField()
    founder = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name='founded_teams'
    )
    team_image = models.ImageField(  # Changed from 'image' to 'team_image'
        upload_to=team_image_upload_path,
        null=True,
        blank=True,
        help_text="Upload a team profile image"
    )
    tags = models.CharField(
        max_length=200, 
        blank=True,
        help_text="Enter tags separated by commas"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ['-created_at']

class TeamMembership(models.Model):
    ROLE_CHOICES = [
        ('founder', 'Founder'),
        ('moderator', 'Moderator'),
        ('member', 'Member'),
    ]
    
    team = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='memberships')
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='team_memberships')
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default='member')
    is_approved = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('team', 'user')

class TeamDiscussion(models.Model):
    team = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='discussions')
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    pinned = models.BooleanField(default=False)
    
    class Meta:
        ordering = ['-pinned', '-created_at']

    def __str__(self):
        return f"{self.title} - {self.team.name}"

class TeamComment(models.Model):
    discussion = models.ForeignKey(TeamDiscussion, on_delete=models.CASCADE, related_name='comments')
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f"Comment by {self.author.username} on {self.discussion.title}"

class TeamAnalytics(models.Model):
    team = models.OneToOneField(Team, on_delete=models.CASCADE, related_name='analytics')
    total_discussions = models.PositiveIntegerField(default=0)
    total_comments = models.PositiveIntegerField(default=0)
    active_members = models.PositiveIntegerField(default=0)
    last_activity = models.DateTimeField(null=True, blank=True)
    
    # Weekly and monthly stats
    discussions_this_week = models.PositiveIntegerField(default=0)
    comments_this_week = models.PositiveIntegerField(default=0)
    discussions_this_month = models.PositiveIntegerField(default=0)
    comments_this_month = models.PositiveIntegerField(default=0)
    
    class Meta:
        verbose_name_plural = "Team analytics"

    def __str__(self):
        return f"Analytics for {self.team.name}"

    def update_stats(self):
        from django.utils import timezone
        from datetime import timedelta
        
        now = timezone.now()
        week_ago = now - timedelta(days=7)
        month_ago = now - timedelta(days=30)
        
        self.total_discussions = self.team.discussions.count()
        self.total_comments = TeamComment.objects.filter(discussion__team=self.team).count()
        self.active_members = TeamMembership.objects.filter(
            team=self.team,
            user__last_login__gte=month_ago
        ).count()
        
        self.discussions_this_week = self.team.discussions.filter(
            created_at__gte=week_ago
        ).count()
        self.comments_this_week = TeamComment.objects.filter(
            discussion__team=self.team,
            created_at__gte=week_ago
        ).count()
        
        self.discussions_this_month = self.team.discussions.filter(
            created_at__gte=month_ago
        ).count()
        self.comments_this_month = TeamComment.objects.filter(
            discussion__team=self.team,
            created_at__gte=month_ago
        ).count()
        
        self.last_activity = now
        self.save()


class Sponsorship(models.Model):
    LEVELS = [
        ('bronze', 'Bronze'),
        ('silver', 'Silver'),
        ('gold', 'Gold'),
        ('platinum', 'Platinum')
    ]
    
    name = models.CharField(max_length=200)
    logo = models.ImageField(upload_to='sponsor_logos/')
    level = models.CharField(max_length=20, choices=LEVELS)
    website = models.URLField()
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)



class Product(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    image = models.ImageField(upload_to='product_images/')
    url = models.URLField()
    created_at = models.DateTimeField(auto_now_add=True)

class Tool(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    image = models.ImageField(upload_to='tool_images/')
    url = models.URLField()
    github_url = models.URLField(blank=True)
    documentation_url = models.URLField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

class Dataset(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    file = models.FileField(upload_to='datasets/')
    size = models.BigIntegerField()  # in bytes
    format = models.CharField(max_length=50)
    license = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    downloads = models.IntegerField(default=0)



# Contents from: .\serializers.py
# projects/serializers.py

from rest_framework import serializers
from django.contrib.auth.models import User
from .models import (
    Project,
    Comment,
    UserProfile,
    Rating,
    Bookmark,
    ProjectAnalytics,
    Notification
)

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'date_joined']

class UserProfileSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    
    class Meta:
        model = UserProfile
        fields = [
            'user', 'bio', 'location', 'website',
            'github_username', 'linkedin_url', 'avatar'
        ]

class ProjectSerializer(serializers.ModelSerializer):
    author = UserSerializer(read_only=True)
    tag_list = serializers.ListField(read_only=True)
    comment_count = serializers.IntegerField(read_only=True)
    average_rating = serializers.FloatField(read_only=True)
    
    class Meta:
        model = Project
        fields = [
            'id', 'title', 'slug', 'description',
            'github_link', 'tags', 'author',
            'claps', 'created_at', 'updated_at',
            'pdf_file', 'featured_image',
            'additional_files', 'tag_list',
            'comment_count', 'average_rating'
        ]
        read_only_fields = ['slug', 'claps']

class CommentSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    replies = serializers.SerializerMethodField()
    
    class Meta:
        model = Comment
        fields = [
            'id', 'project', 'user', 'parent',
            'content', 'image', 'created_at',
            'updated_at', 'replies'
        ]
        read_only_fields = ['user']
    
    def get_replies(self, obj):
        if obj.replies.exists():
            return CommentSerializer(obj.replies.all(), many=True).data
        return []

class RatingSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    
    class Meta:
        model = Rating
        fields = [
            'id', 'project', 'user', 'score',
            'review', 'created_at', 'updated_at'
        ]
        read_only_fields = ['user']

class BookmarkSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True)
    project = ProjectSerializer(read_only=True)
    
    class Meta:
        model = Bookmark
        fields = ['id', 'user', 'project', 'created_at', 'notes']
        read_only_fields = ['user']

class NotificationSerializer(serializers.ModelSerializer):
    sender = UserSerializer(read_only=True)
    recipient = UserSerializer(read_only=True)
    project = ProjectSerializer(read_only=True)
    
    class Meta:
        model = Notification
        fields = [
            'id', 'recipient', 'sender', 'project',
            'notification_type', 'message', 'is_read',
            'created_at'
        ]
        read_only_fields = ['recipient', 'sender', 'project']

class ProjectAnalyticsSerializer(serializers.ModelSerializer):
    project = ProjectSerializer(read_only=True)
    device_distribution = serializers.SerializerMethodField()
    browser_distribution = serializers.SerializerMethodField()
    traffic_sources = serializers.SerializerMethodField()
    
    class Meta:
        model = ProjectAnalytics
        fields = [
            'project', 'view_count', 'unique_visitors',
            'github_clicks', 'avg_time_spent',
            'direct_traffic', 'social_traffic',
            'search_traffic', 'referral_traffic',
            'desktop_visits', 'mobile_visits',
            'tablet_visits', 'chrome_visits',
            'firefox_visits', 'safari_visits',
            'edge_visits', 'other_browsers',
            'unique_visitors_weekly', 'unique_visitors_monthly',
            'github_clicks_weekly', 'github_clicks_monthly',
            'device_distribution', 'browser_distribution',
            'traffic_sources', 'last_updated'
        ]
        read_only_fields = ['project']
    
    def get_device_distribution(self, obj):
        total = obj.desktop_visits + obj.mobile_visits + obj.tablet_visits
        if total == 0:
            return {
                'desktop': 0,
                'mobile': 0,
                'tablet': 0
            }
        
        return {
            'desktop': round((obj.desktop_visits / total) * 100, 1),
            'mobile': round((obj.mobile_visits / total) * 100, 1),
            'tablet': round((obj.tablet_visits / total) * 100, 1)
        }
    
    def get_browser_distribution(self, obj):
        total = (
            obj.chrome_visits + obj.firefox_visits +
            obj.safari_visits + obj.edge_visits + obj.other_browsers
        )
        
        if total == 0:
            return {
                'chrome': 0,
                'firefox': 0,
                'safari': 0,
                'edge': 0,
                'other': 0
            }
        
        return {
            'chrome': round((obj.chrome_visits / total) * 100, 1),
            'firefox': round((obj.firefox_visits / total) * 100, 1),
            'safari': round((obj.safari_visits / total) * 100, 1),
            'edge': round((obj.edge_visits / total) * 100, 1),
            'other': round((obj.other_browsers / total) * 100, 1)
        }
    
    def get_traffic_sources(self, obj):
        total = (
            obj.direct_traffic + obj.social_traffic +
            obj.search_traffic + obj.referral_traffic
        )
        
        if total == 0:
            return {
                'direct': 0,
                'social': 0,
                'search': 0,
                'referral': 0
            }
        
        return {
            'direct': round((obj.direct_traffic / total) * 100, 1),
            'social': round((obj.social_traffic / total) * 100, 1),
            'search': round((obj.search_traffic / total) * 100, 1),
            'referral': round((obj.referral_traffic / total) * 100, 1)
        }

class ProjectAnalyticsSummarySerializer(serializers.ModelSerializer):
    """Lightweight serializer for analytics summary"""
    class Meta:
        model = ProjectAnalytics
        fields = ['view_count', 'unique_visitors', 'github_clicks']

# Contents from: .\signals.py
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.db.models import F
from .models import TeamMembership, TeamDiscussion, TeamComment, TeamAnalytics
from .utils.team_emails import send_team_notification_email, send_role_change_notification

@receiver(post_save, sender=TeamDiscussion)
def handle_new_discussion(sender, instance, created, **kwargs):
    if created:
        # Update analytics
        analytics = instance.team.analytics
        analytics.total_discussions = F('total_discussions') + 1
        analytics.discussions_this_week = F('discussions_this_week') + 1
        analytics.discussions_this_month = F('discussions_this_month') + 1
        analytics.save()
        
        # Notify team members
        for membership in instance.team.memberships.filter(
            is_approved=True,
            notification_preferences__in_app_notifications=True
        ).exclude(user=instance.author):
            send_team_notification_email(
                membership.user,
                instance.team,
                'discussion',
                {'discussion': instance}
            )

@receiver(post_save, sender=TeamComment)
def handle_new_comment(sender, instance, created, **kwargs):
    if created:
        # Update analytics
        analytics = instance.discussion.team.analytics
        analytics.total_comments = F('total_comments') + 1
        analytics.comments_this_week = F('comments_this_week') + 1
        analytics.comments_this_month = F('comments_this_month') + 1
        analytics.save()
        
        # Notify team members
        for membership in instance.discussion.team.memberships.filter(
            is_approved=True,
            notification_preferences__in_app_notifications=True
        ).exclude(user=instance.author):
            send_team_notification_email(
                membership.user,
                instance.discussion.team,
                'comment',
                {'comment': instance}
            )

@receiver(post_save, sender=TeamMembership)
def handle_membership_changes(sender, instance, created, **kwargs):
    if not created and instance.tracker.has_changed('role'):
        send_role_change_notification(
            instance.user,
            instance.team,
            instance.get_role_display()
        )

@receiver(post_delete, sender=TeamMembership)
def handle_member_removal(sender, instance, **kwargs):
    # Update analytics
    instance.team.analytics.update_stats()

# Contents from: .\templatetags\__init__.py


# Contents from: .\templatetags\custom_filters.py
# projects/templatetags/custom_filters.py

from django import template

register = template.Library()

@register.filter
def split(value, arg):
    """Split a string by the given delimiter"""
    return value.split(arg)

# Contents from: .\templatetags\project_tags.py
# projects/templatetags/project_tags.py

from django import template
from django.db.models import Q
from ..models import Project

register = template.Library()

@register.simple_tag
def get_similar_projects(project):
    """Returns similar projects based on tags"""
    if not project.tags:
        return Project.objects.exclude(id=project.id)[:3]
    
    tags = [tag.strip() for tag in project.tags.split(',')]
    similar_projects = Project.objects.filter(
        tags__icontains=tags[0]
    ).exclude(id=project.id)
    
    for tag in tags[1:]:
        similar_projects = similar_projects | Project.objects.filter(
            tags__icontains=tag
        ).exclude(id=project.id)
    
    return similar_projects.distinct()[:3]

# Contents from: .\templatetags\query_tags.py
# templatetags/query_tags.py

from django import template
from django.utils.http import urlencode

register = template.Library()

@register.simple_tag
def query_transform(request_get, param_name, value, action='add'):
    """
    Transform query parameters while preserving other parameters
    """
    updated = request_get.copy()
    
    if action == 'remove':
        # Remove a specific value from a comma-separated list
        current_values = updated.get(param_name, '').split(',')
        current_values = [v for v in current_values if v and v != value]
        if current_values:
            updated[param_name] = ','.join(current_values)
        else:
            updated.pop(param_name, None)
    else:
        # Add or replace value
        if value:
            updated[param_name] = value
        else:
            updated.pop(param_name, None)
    
    return '?' + urlencode(updated)

# Contents from: .\templatetags\search_tags.py
# projects/templatetags/search_tags.py

from django import template
from django.utils.html import mark_safe
from django.utils.html import escape
import re

register = template.Library()

@register.filter(name='highlight')
def highlight_search_term(text, search_term):
    """Highlight search terms in text while preserving HTML safety"""
    if not search_term or not text:
        return text
    
    text = str(text)
    search_term = str(search_term)
    
    # Escape HTML in the text
    text = escape(text)
    
    # Create a pattern that matches whole words
    pattern = r'({})'.format(re.escape(search_term))
    
    # Replace matches with highlighted version
    highlighted = re.sub(
        pattern,
        r'<mark class="highlight">\1</mark>',
        text,
        flags=re.IGNORECASE
    )
    
    return mark_safe(highlighted)

@register.filter(name='querystring_without')
def querystring_without(query_dict, key):
    """Remove a key from querystring while preserving other parameters"""
    query_dict = query_dict.copy()
    query_dict.pop(key, None)
    return query_dict.urlencode()

@register.simple_tag
def url_with_querystring(request, **kwargs):
    """Build URL with updated querystring parameters"""
    query_dict = request.GET.copy()
    for key, value in kwargs.items():
        query_dict[key] = value
    return '?{}'.format(query_dict.urlencode())

# Contents from: .\templatetags\team_tags.py
from django import template

register = template.Library()

@register.filter
def split(value, arg):
    """
    Splits a string into a list on the given delimiter
    Usage: {{ value|split:"," }}
    """
    return [x.strip() for x in value.split(arg)]

# Contents from: .\tests.py
from django.test import TestCase

# Create your tests here.


# Contents from: .\tests\team_tests.py
from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.auth.models import User
from projects.models import Team, TeamMembership, TeamDiscussion, TeamComment
from datetime import timedelta
from django.utils import timezone

class TeamTests(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user('testuser', 'test@test.com', 'testpass')
        self.client.login(username='testuser', password='testpass')
        
        self.team = Team.objects.create(
            name='Test Team',
            description='Test Description',
            founder=self.user,
            max_members=10
        )
        TeamMembership.objects.create(
            team=self.team,
            user=self.user,
            role='founder',
            is_approved=True
        )

    def test_team_creation(self):
        response = self.client.post(reverse('create_team'), {
            'name': 'New Team',
            'description': 'New Description',
            'max_members': 15
        })
        self.assertEqual(response.status_code, 302)
        self.assertTrue(Team.objects.filter(name='New Team').exists())

    def test_team_join(self):
        new_user = User.objects.create_user('newuser', 'new@test.com', 'newpass')
        self.client.login(username='newuser', password='newpass')
        
        response = self.client.post(reverse('join_team', args=[self.team.slug]))
        self.assertEqual(response.status_code, 302)
        self.assertTrue(TeamMembership.objects.filter(
            team=self.team,
            user=new_user,
            is_approved=False
        ).exists())

    def test_discussion_creation(self):
        response = self.client.post(
            reverse('create_discussion', args=[self.team.slug]),
            {
                'title': 'Test Discussion',
                'content': 'Test Content'
            }
        )
        self.assertEqual(response.status_code, 302)
        self.assertTrue(TeamDiscussion.objects.filter(
            team=self.team,
            title='Test Discussion'
        ).exists())

    def test_analytics_updates(self):
        discussion = TeamDiscussion.objects.create(
            team=self.team,
            author=self.user,
            title='Test Discussion',
            content='Test Content'
        )
        
        analytics = self.team.analytics
        self.assertEqual(analytics.total_discussions, 1)
        self.assertEqual(analytics.discussions_this_week, 1)

        TeamComment.objects.create(
            discussion=discussion,
            author=self.user,
            content='Test Comment'
        )
        
        analytics.refresh_from_db()
        self.assertEqual(analytics.total_comments, 1)
        self.assertEqual(analytics.comments_this_week, 1)

    def test_notification_preferences(self):
        membership = TeamMembership.objects.get(team=self.team, user=self.user)
        membership.notification_preferences = {
            'email_notifications': False,
            'in_app_notifications': True
        }
        membership.save()
        
        membership.refresh_from_db()
        self.assertFalse(membership.notification_preferences['email_notifications'])
        self.assertTrue(membership.notification_preferences['in_app_notifications'])

    def test_member_permissions(self):
        regular_user = User.objects.create_user('regular', 'regular@test.com', 'pass')
        membership = TeamMembership.objects.create(
            team=self.team,
            user=regular_user,
            role='member',
            is_approved=True
        )
        
        self.client.login(username='regular', password='pass')
        
        # Try to access team settings (should be forbidden)
        response = self.client.get(reverse('team_settings', args=[self.team.slug]))
        self.assertEqual(response.status_code, 403)

        # Can create discussions
        response = self.client.post(
            reverse('create_discussion', args=[self.team.slug]),
            {'title': 'Member Discussion', 'content': 'Content'}
        )
        self.assertEqual(response.status_code, 302)

# Contents from: .\tests\team_tests_api.py
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth.models import User
from projects.models import Team, TeamMembership

class TeamAPITests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user('testuser', 'test@test.com', 'testpass')
        self.client.login(username='testuser', password='testpass')
        
        self.team = Team.objects.create(
            name='Test Team',
            description='Test Description',
            founder=self.user
        )
        TeamMembership.objects.create(
            team=self.team,
            user=self.user,
            role='founder',
            is_approved=True
        )

    def test_team_list_api(self):
        response = self.client.get(reverse('api_team_list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)

    def test_team_detail_api(self):
        response = self.client.get(reverse('api_team_detail', args=[self.team.slug]))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], 'Test Team')

    def test_team_analytics_api(self):
        response = self.client.get(reverse('api_team_analytics', args=[self.team.slug]))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('total_discussions', response.data)

    def test_unauthorized_access(self):
        self.client.logout()
        response = self.client.get(reverse('api_team_list'))
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

# Contents from: .\urls.py
# urls.py

from django.urls import path
from django.contrib.auth.decorators import login_required
from . import views

app_name = 'projects'

urlpatterns = [
    # Homepage and Project List
    path('', views.homepage, name='homepage'),
    path('projects/', views.project_list, name='project_list'),
    
    # Project Management
    path('submit/', views.submit_project, name='submit_project'),
    path('search/', views.search_projects, name='search_projects'),
    path('leaderboard/', views.leaderboard_view, name='leaderboard'),
    
    # Project Detail & Actions
    path('project/<int:pk>/', views.project_detail, name='project_detail'),
    path('project/<int:pk>/edit/', views.edit_project, name='edit_project'),
    path('project/<int:pk>/rate/', views.rate_project, name='rate_project'),
    path('project/<int:pk>/bookmark/', views.bookmark_project, name='bookmark_project'),
    path('project/<int:pk>/clap/', views.clap_project, name='clap_project'),
    path('project/<int:pk>/delete/', views.delete_project, name='delete_project'),
    
    # Analytics
    path('project/<int:pk>/analytics/', views.ProjectAnalyticsView.as_view(), name='project_analytics'),
    path('project/<int:pk>/analytics/data/', views.analytics_data, name='analytics_data'),
    path('project/<int:pk>/analytics/export/csv/', views.export_analytics_csv, name='export_analytics_csv'),
    path('project/<int:pk>/analytics/export/pdf/', views.export_analytics_pdf, name='export_analytics_pdf'),
    
    # User Profiles
    path('profile/edit/', views.edit_profile, name='edit_profile'),
    path('profile/settings/', views.profile_settings, name='profile_settings'),
    path('profile/<str:username>/', views.user_profile, name='user_profile'),
    path('profile/<str:username>/projects/', views.user_projects, name='user_projects'),
    path('profile/<str:username>/follow/', views.follow_user, name='follow_user'),
    path('profile/<str:username>/unfollow/', views.unfollow_user, name='unfollow_user'),
    
    # Notifications
    path('notifications/', views.notifications, name='notifications'),
    path('notifications/<int:notification_id>/mark-read/', 
         views.mark_notification_read, name='mark_notification_read'),
    path('notifications/mark-all-read/', 
         views.mark_all_notifications_read, name='mark_all_notifications_read'),
    
    # Comments
    path('comment/<int:pk>/delete/', views.delete_comment, name='delete_comment'),
    path('comment/<int:pk>/edit/', views.edit_comment, name='edit_comment'),
    path('comment/<int:pk>/clap/', views.clap_comment, name='clap_comment'),
    
    # Startups
    path('startups/', views.StartupListView.as_view(), name='startup_list'),
    path('startups/create/', 
         login_required(views.StartupCreateView.as_view()), 
         name='create_startup'),
    
    # Tools
    path('tools/', views.ToolListView.as_view(), name='tool_list'),
    path('tools/create/', 
         login_required(views.ToolCreateView.as_view()), 
         name='create_tool'),
    
    # Datasets
    path('datasets/', views.DatasetListView.as_view(), name='dataset_list'),
    path('datasets/create/', 
         login_required(views.DatasetCreateView.as_view()), 
         name='create_dataset'),
    
    # Downloads
    path('project/<int:pk>/download/', views.download_project, name='download_project'),
    path('dataset/<int:pk>/download/', views.download_dataset, name='download_dataset'),
    
    # Sponsorships and Applications
    path('sponsorships/', views.SponsorshipListView.as_view(), name='sponsorship_list'),
    path('virtual-members/', views.VirtualMemberListView.as_view(), name='virtual_member_list'),
    path('apply/', login_required(views.ApplicationCreateView.as_view()), name='apply'),
    
    # Other pages
    path('faculty/', views.faculty_page, name='faculty_page'),
    path('careers/', views.careers_page, name='careers'),
    path('talents/', views.talents_page, name='talents'),
    path('help/', views.help_view, name='help'),
    
    path('api/projects/<int:pk>/generate-tags/', 
         views.generate_tags, 
         name='api_generate_tags'),
    
    path('api/projects/<int:project_pk>/add-virtual-member/', 
         views.add_virtual_member, 
         name='api_add_virtual_member'),
    
    path('api/projects/<int:project_pk>/remove-virtual-member/<int:member_pk>/',
         views.remove_virtual_member,
         name='api_remove_virtual_member'),
    
    path('api/projects/<int:pk>/analytics/', 
         views.project_analytics_api,  # Changed to match the view function name
         name='api_project_analytics'),
    
    # Solutions
    path('project/<int:pk>/submit-solution/', 
         views.submit_solution, name='submit_solution'),
    path('project/<int:project_pk>/solution/<int:solution_pk>/review/', 
         views.review_solution, name='review_solution'),
    path('teams/', views.team_list, name='team_list'),
    path('teams/create/', views.create_team, name='create_team'),
    path('teams/<slug:team_slug>/', views.team_detail, name='team_detail'),
    path('faq/', views.faq, name='faq'),
]

# Contents from: .\utils\__init__.py
# This file can be empty

# Contents from: .\utils\emails.py
# projects/utils/emails.py

from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags
from django.conf import settings

def send_notification_email(notification):
    """Send email for a new notification if user has enabled that notification type"""
    recipient_profile = notification.recipient.profile
    
    # Check if user wants this type of email notification
    should_send = False
    
    if notification.notification_type == 'comment' and recipient_profile.email_on_comment:
        should_send = True
    elif notification.notification_type == 'follow' and recipient_profile.email_on_follow:
        should_send = True
    elif notification.notification_type == 'clap' and recipient_profile.email_on_clap:
        should_send = True
    elif notification.notification_type == 'bookmark' and recipient_profile.email_on_bookmark:
        should_send = True
    
    if should_send:
        subject = f'New notification from {settings.SITE_NAME}'
        context = {
            'notification': notification,
            'site_url': settings.SITE_URL,
            'unsubscribe_url': f"{settings.SITE_URL}/settings/notifications/"
        }
        
        html_message = render_to_string('emails/notification.html', context)
        plain_message = strip_tags(html_message)
        
        send_mail(
            subject,
            plain_message,
            settings.DEFAULT_FROM_EMAIL,
            [notification.recipient.email],
            html_message=html_message,
            fail_silently=True
        )

def send_welcome_email(user):
    """Send welcome email to new users"""
    subject = f'Welcome to {settings.SITE_NAME}'
    context = {
        'user': user,
        'site_url': settings.SITE_URL,
        'unsubscribe_url': f"{settings.SITE_URL}/settings/notifications/"
    }
    
    html_message = render_to_string('emails/welcome.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        subject,
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

def send_comment_notification(comment):
    """Send email notification for new comments"""
    subject = f'New comment on your project - {settings.SITE_NAME}'
    context = {
        'comment': comment,
        'project': comment.project,
        'site_url': settings.SITE_URL,
        'unsubscribe_url': f"{settings.SITE_URL}/settings/notifications/"
    }
    
    html_message = render_to_string('emails/project_comment.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        subject,
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [comment.project.author.email],
        html_message=html_message,
        fail_silently=True
    )

def send_clap_notification(clap):
    """Send email notification for new claps"""
    subject = f'Someone appreciated your project - {settings.SITE_NAME}'
    context = {
        'clap': clap,
        'project': clap.project,
        'site_url': settings.SITE_URL,
        'unsubscribe_url': f"{settings.SITE_URL}/settings/notifications/"
    }
    
    html_message = render_to_string('emails/project_clap.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        subject,
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [clap.project.author.email],
        html_message=html_message,
        fail_silently=True
    )

# Contents from: .\utils\pdf.py
from io import BytesIO
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.units import inch

def generate_analytics_pdf(project, analytics_data):
    """Generate a PDF report for project analytics"""
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []

    # Title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30
    )
    story.append(Paragraph(f"Analytics Report: {project.title}", title_style))
    story.append(Spacer(1, 12))

    # Overview Section
    story.append(Paragraph("Overview", styles['Heading2']))
    overview_data = [
        ["Total Views", str(analytics_data.get('view_count', 0))],
        ["Unique Visitors", str(analytics_data.get('unique_visitors', 0))],
        ["GitHub Clicks", str(analytics_data.get('github_clicks', 0))],
    ]
    overview_table = Table(overview_data, colWidths=[2*inch, 2*inch])
    overview_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, -1), colors.lightgrey),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, -1), 14),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ('TOPPADDING', (0, 0), (-1, -1), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    story.append(overview_table)
    story.append(Spacer(1, 20))

    # Traffic Sources
    story.append(Paragraph("Traffic Sources", styles['Heading2']))
    traffic_data = [
        ["Direct", f"{analytics_data.get('direct_traffic', 0)}%"],
        ["Social", f"{analytics_data.get('social_traffic', 0)}%"],
        ["Search", f"{analytics_data.get('search_traffic', 0)}%"],
        ["Referral", f"{analytics_data.get('referral_traffic', 0)}%"],
    ]
    traffic_table = Table(traffic_data, colWidths=[2*inch, 2*inch])
    traffic_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, -1), colors.lightgrey),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 12),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ('TOPPADDING', (0, 0), (-1, -1), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    story.append(traffic_table)
    story.append(Spacer(1, 20))

    # Device Distribution
    story.append(Paragraph("Device Distribution", styles['Heading2']))
    device_data = [
        ["Desktop", f"{analytics_data.get('desktop_visits', 0)}%"],
        ["Mobile", f"{analytics_data.get('mobile_visits', 0)}%"],
        ["Tablet", f"{analytics_data.get('tablet_visits', 0)}%"],
    ]
    device_table = Table(device_data, colWidths=[2*inch, 2*inch])
    device_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, -1), colors.lightgrey),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 12),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
        ('TOPPADDING', (0, 0), (-1, -1), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    story.append(device_table)

    # Build PDF
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    return pdf

# Contents from: .\utils\team_emails.py
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings

def send_team_notification_email(user, team, notification_type, context=None):
    """Send email notifications for team activities"""
    if context is None:
        context = {}
    
    context.update({
        'user': user,
        'team': team,
        'site_url': settings.SITE_URL
    })
    
    templates = {
        'discussion': 'emails/team_discussion.html',
        'comment': 'emails/team_comment.html',
        'role_change': 'emails/team_role_change.html',
        'invitation': 'emails/team_invitation.html'
    }
    
    template = templates.get(notification_type)
    if not template:
        return
        
    html_message = render_to_string(template, context)
    plain_message = strip_tags(html_message)
    
    subject = f"New activity in {team.name} - {notification_type.title()}"
    
    send_mail(
        subject,
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

def send_team_invitation_email(user, team, inviter):
    """Send email for team invitation"""
    context = {
        'user': user,
        'team': team,
        'inviter': inviter,
        'site_url': settings.SITE_URL
    }
    
    html_message = render_to_string('emails/team_invitation.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        f"Invitation to join {team.name}",
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

def send_role_change_notification(user, team, new_role):
    """Send email for role changes"""
    context = {
        'user': user,
        'team': team,
        'new_role': new_role,
        'site_url': settings.SITE_URL
    }
    
    html_message = render_to_string('emails/team_role_change.html', context)
    plain_message = strip_tags(html_message)
    
    send_mail(
        f"Role update in {team.name}",
        plain_message,
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        html_message=html_message,
        fail_silently=True
    )

# Contents from: .\views.py
from datetime import datetime, timedelta
from io import StringIO, BytesIO
import csv
import json
import os
import pytz
import zipfile

from django.views import generic
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse, HttpResponseNotAllowed
from django.core.exceptions import PermissionDenied
from django.contrib import messages
from django.urls import reverse, reverse_lazy
from django.conf import settings
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User
from django.core.cache import cache
from django.core.files.storage import default_storage
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.core.serializers import serialize
from django.db.models import Count, Q, Avg, Sum, Case, When
from django.utils import timezone
from django.views.generic import DetailView
from django.views.generic.edit import CreateView

from rest_framework import generics
from rest_framework.permissions import IsAuthenticated

from khcc_psut_ai_lab.constants import TALENT_TYPES, TALENT_DICT

from .filters.project_filters import ProjectFilter
from .forms import (
    ProjectForm, CommentForm, ProjectSearchForm, UserProfileForm,
    RatingForm, BookmarkForm, AdvancedSearchForm, ProfileForm, 
    NotificationSettingsForm, ExtendedUserCreationForm,
    SolutionForm, TeamForm, TeamDiscussionForm, TeamCommentForm, 
    TeamNotificationSettingsForm, StartupForm, ProductForm, ToolForm,
    DatasetForm, SponsorshipForm, VirtualMemberForm, ApplicationForm
)

from .models import (
    Project, Comment, Clap, UserProfile, Rating,
    Bookmark, ProjectAnalytics, Notification, Follow,
    CommentClap, Solution, Team, TeamMembership, 
    TeamDiscussion, TeamComment, TeamAnalytics,
    Sponsorship, Startup, Product, Tool, Dataset,
    VirtualMember, Application
)

from .serializers import ProjectSerializer, ProjectAnalyticsSerializer, ProjectAnalyticsSummarySerializer
from .utils.pdf import generate_analytics_pdf

from django.views import generic
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse, HttpResponseNotAllowed
from django.core.exceptions import PermissionDenied
from django.contrib import messages
from django.urls import reverse
from django.conf import settings
from django.utils import timezone
from datetime import timedelta
import os
import zipfile
from io import BytesIO

# DRF imports
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

# Import all models
from .models import (
    Project, Comment, UserProfile, Rating, Bookmark, 
    ProjectAnalytics, Notification, Follow, CommentClap,
    Solution, Startup, Product, Tool, Dataset,
    VirtualMember, Application, Sponsorship
)

# Import all forms
from .forms import (
    ProjectForm, CommentForm, UserProfileForm, RatingForm,
    BookmarkForm, AdvancedSearchForm, ProfileForm,
    NotificationSettingsForm, ExtendedUserCreationForm,
    SolutionForm, StartupForm, ProductForm, ToolForm,
    DatasetForm, SponsorshipForm, VirtualMemberForm,
    ApplicationForm
)

# Add these to your views.py file

from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def add_virtual_member(request, project_pk):
    """Add a virtual member to a project"""
    project = get_object_or_404(Project, pk=project_pk)
    
    # Check permissions
    if project.author != request.user:
        return Response({
            "status": "error",
            "message": "Permission denied"
        }, status=status.HTTP_403_FORBIDDEN)
    
    try:
        member_id = request.data.get('member_id')
        if not member_id:
            return Response({
                "status": "error",
                "message": "member_id is required"
            }, status=status.HTTP_400_BAD_REQUEST)
            
        virtual_member = get_object_or_404(VirtualMember, pk=member_id)
        
        # Check if member is already added
        if virtual_member in project.virtual_members.all():
            return Response({
                "status": "error",
                "message": "Virtual member already added to this project"
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Add virtual member to project
        project.virtual_members.add(virtual_member)
        
        return Response({
            "status": "success",
            "message": f"Added {virtual_member.name} to project",
            "member": {
                "id": virtual_member.id,
                "name": virtual_member.name,
                "specialty": virtual_member.specialty
            }
        })
    except Exception as e:
        return Response({
            "status": "error",
            "message": str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def remove_virtual_member(request, project_pk, member_pk):
    """Remove a virtual member from a project"""
    project = get_object_or_404(Project, pk=project_pk)
    
    # Check permissions
    if project.author != request.user:
        return Response({
            "status": "error",
            "message": "Permission denied"
        }, status=status.HTTP_403_FORBIDDEN)
    
    try:
        virtual_member = get_object_or_404(VirtualMember, pk=member_pk)
        
        # Check if member is in project
        if virtual_member not in project.virtual_members.all():
            return Response({
                "status": "error",
                "message": "Virtual member not found in this project"
            }, status=status.HTTP_404_NOT_FOUND)
        
        # Remove virtual member from project
        project.virtual_members.remove(virtual_member)
        
        return Response({
            "status": "success",
            "message": f"Removed {virtual_member.name} from project"
        })
    except Exception as e:
        return Response({
            "status": "error",
            "message": str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# views.py

from django.conf import settings
import openai
from khcc_psut_ai_lab.constants import ALL_TAGS
from difflib import get_close_matches

def get_similar_tags(suggested_tag, valid_tags=ALL_TAGS, n=1, cutoff=0.6):
    """Find the closest matching valid tag"""
    matches = get_close_matches(suggested_tag.lower(), valid_tags, n=n, cutoff=cutoff)
    return matches[0] if matches else suggested_tag

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def generate_tags(request, pk):
    """Generate tags for a project using OpenAI"""
    project = get_object_or_404(Project, pk=pk)
    
    # Check permissions
    if project.author != request.user:
        return Response({
            "status": "error",
            "message": "Permission denied"
        }, status=status.HTTP_403_FORBIDDEN)
    
    try:
        # Set up OpenAI client
        openai.api_key = settings.OPENAI_API_KEY
        
        # Prepare the prompt
        prompt = f"""
        Please analyze the following project and suggest relevant tags from the predefined list.
        The tags should be highly relevant to AI and healthcare domains.
        
        Project Title: {project.title}
        Project Description: {project.description}
        
        Available Tags: {', '.join(ALL_TAGS)}
        
        Please suggest 3-5 most relevant tags from the available tags list above.
        Return only the tags in a comma-separated format.
        Prefer exact matches from the available tags, but suggest close alternatives if needed.
        """
        
        # Make API call to OpenAI
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a specialized AI trained to analyze healthcare and AI projects and assign relevant tags."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,  # Lower temperature for more focused responses
            max_tokens=100
        )
        
        # Extract suggested tags from response
        suggested_tags = response.choices[0].message['content'].strip().split(',')
        suggested_tags = [tag.strip().lower() for tag in suggested_tags]
        
        # Map suggested tags to valid tags
        final_tags = []
        for tag in suggested_tags:
            if tag in ALL_TAGS:
                final_tags.append(tag)
            else:
                # Find similar valid tag
                similar_tag = get_similar_tags(tag)
                if similar_tag:
                    final_tags.append(similar_tag)
        
        # Remove duplicates and limit to 5 tags
        final_tags = list(dict.fromkeys(final_tags))[:5]
        
        # Update project's generated tags
        project.generated_tags = ",".join(final_tags)
        project.save()
        
        return Response({
            "status": "success",
            "tags": final_tags,
            "message": "Tags generated successfully using AI"
        })
        
    except openai.error.OpenAIError as e:
        return Response({
            "status": "error",
            "message": f"OpenAI API error: {str(e)}"
        }, status=status.HTTP_503_SERVICE_UNAVAILABLE)
        
    except Exception as e:
        return Response({
            "status": "error",
            "message": str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def project_analytics_api(request, pk):
    """Get project analytics data"""
    project = get_object_or_404(Project, pk=pk)
    
    # Check permissions
    if project.author != request.user and not request.user.is_staff:
        return Response({
            "status": "error",
            "message": "Permission denied"
        }, status=status.HTTP_403_FORBIDDEN)
    
    try:
        analytics = project.analytics
        
        # Get time period from query params
        period = request.GET.get('period', 'all')  # all, week, month
        
        if period == 'week':
            start_date = timezone.now() - timedelta(days=7)
        elif period == 'month':
            start_date = timezone.now() - timedelta(days=30)
        else:
            start_date = None
            
        data = {
            "overview": {
                "views": analytics.view_count,
                "unique_visitors": analytics.unique_visitors,
                "github_clicks": analytics.github_clicks,
                "avg_time_spent": str(analytics.avg_time_spent),
            },
            "device_stats": {
                "desktop": analytics.desktop_visits,
                "mobile": analytics.mobile_visits,
                "tablet": analytics.tablet_visits
            },
            "browser_stats": {
                "chrome": analytics.chrome_visits,
                "firefox": analytics.firefox_visits,
                "safari": analytics.safari_visits,
                "edge": analytics.edge_visits,
                "other": analytics.other_browsers
            },
            "traffic_sources": {
                "direct": analytics.direct_traffic,
                "social": analytics.social_traffic,
                "search": analytics.search_traffic,
                "referral": analytics.referral_traffic
            },
            "engagement": {
                "comments": project.comments.count(),
                "claps": project.clap_count,
                "bookmarks": project.bookmarks.count(),
                "average_rating": project.average_rating
            }
        }
        
        # Add periodic stats if a period is specified
        if start_date:
            data["periodic_stats"] = {
                "views": analytics.get_views_for_period(start_date),
                "unique_visitors": analytics.get_unique_visitors_for_period(start_date),
                "github_clicks": analytics.get_github_clicks_for_period(start_date),
                "comments": project.comments.filter(created_at__gte=start_date).count(),
                "claps": Clap.objects.filter(project=project, created_at__gte=start_date).count()
            }
        
        return Response({
            "status": "success",
            "data": data
        })
        
    except Exception as e:
        return Response({
            "status": "error",
            "message": str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class ProjectAnalyticsView(LoginRequiredMixin, DetailView):
    model = Project
    template_name = 'projects/project_analytics.html'
    context_object_name = 'project'

    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        if obj.author != self.request.user and not self.request.user.is_staff:
            raise PermissionDenied
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        analytics = self.object.analytics
        now = timezone.now()
        
        # Calculate date ranges
        week_ago = now - timedelta(days=7)
        month_ago = now - timedelta(days=30)
        
        # Get weekly and monthly stats
        weekly_stats = {
            'views': analytics.get_views_count(since=week_ago),
            'unique_visitors': analytics.get_unique_visitors_count(since=week_ago),
            'github_clicks': analytics.get_github_clicks_count(since=week_ago),
            'comments': self.object.comments.filter(created_at__gte=week_ago).count(),
            'claps': self.object.claps_set.filter(created_at__gte=week_ago).count(),
            'ratings': self.object.ratings.filter(created_at__gte=week_ago).count()
        }
        
        monthly_stats = {
            'views': analytics.get_views_count(since=month_ago),
            'unique_visitors': analytics.get_unique_visitors_count(since=month_ago),
            'github_clicks': analytics.get_github_clicks_count(since=month_ago),
            'comments': self.object.comments.filter(created_at__gte=month_ago).count(),
            'claps': self.object.claps_set.filter(created_at__gte=month_ago).count(),
            'ratings': self.object.ratings.filter(created_at__gte=month_ago).count()
        }
        
        # Calculate trends
        def calculate_trend(current, previous):
            if previous == 0:
                return 100 if current > 0 else 0
            return round(((current - previous) / previous) * 100, 1)

        trends = {
            'views': calculate_trend(
                weekly_stats['views'], 
                analytics.get_views_count(since=week_ago - timedelta(days=7), until=week_ago)
            ),
            'visitors': calculate_trend(
                weekly_stats['unique_visitors'],
                analytics.get_unique_visitors_count(since=week_ago - timedelta(days=7), until=week_ago)
            ),
            'github': calculate_trend(
                weekly_stats['github_clicks'],
                analytics.get_github_clicks_count(since=week_ago - timedelta(days=7), until=week_ago)
            )
        }
        
        # Get traffic sources breakdown
        total_traffic = (
            analytics.direct_traffic + 
            analytics.social_traffic + 
            analytics.search_traffic + 
            analytics.referral_traffic
        )
        
        traffic_sources = {
            'direct': {
                'count': analytics.direct_traffic,
                'percentage': round((analytics.direct_traffic / total_traffic * 100), 1) if total_traffic > 0 else 0
            },
            'social': {
                'count': analytics.social_traffic,
                'percentage': round((analytics.social_traffic / total_traffic * 100), 1) if total_traffic > 0 else 0
            },
            'search': {
                'count': analytics.search_traffic,
                'percentage': round((analytics.search_traffic / total_traffic * 100), 1) if total_traffic > 0 else 0
            },
            'referral': {
                'count': analytics.referral_traffic,
                'percentage': round((analytics.referral_traffic / total_traffic * 100), 1) if total_traffic > 0 else 0
            }
        }
        
        # Device and browser stats
        total_visits = (
            analytics.desktop_visits + 
            analytics.mobile_visits + 
            analytics.tablet_visits
        )
        
        devices = {
            'desktop': {
                'count': analytics.desktop_visits,
                'percentage': round((analytics.desktop_visits / total_visits * 100), 1) if total_visits > 0 else 0
            },
            'mobile': {
                'count': analytics.mobile_visits,
                'percentage': round((analytics.mobile_visits / total_visits * 100), 1) if total_visits > 0 else 0
            },
            'tablet': {
                'count': analytics.tablet_visits,
                'percentage': round((analytics.tablet_visits / total_visits * 100), 1) if total_visits > 0 else 0
            }
        }
        
        total_browser_visits = (
            analytics.chrome_visits +
            analytics.firefox_visits +
            analytics.safari_visits +
            analytics.edge_visits +
            analytics.other_browsers
        )
        
        browsers = [
            {
                'name': 'Chrome',
                'count': analytics.chrome_visits,
                'percentage': round((analytics.chrome_visits / total_browser_visits * 100), 1) if total_browser_visits > 0 else 0,
                'color': '#4285F4',
                'icon': 'browser-chrome'
            },
            {
                'name': 'Firefox',
                'count': analytics.firefox_visits,
                'percentage': round((analytics.firefox_visits / total_browser_visits * 100), 1) if total_browser_visits > 0 else 0,
                'color': '#FF7139',
                'icon': 'browser-firefox'
            },
            {
                'name': 'Safari',
                'count': analytics.safari_visits,
                'percentage': round((analytics.safari_visits / total_browser_visits * 100), 1) if total_browser_visits > 0 else 0,
                'color': '#000000',
                'icon': 'browser-safari'
            },
            {
                'name': 'Edge',
                'count': analytics.edge_visits,
                'percentage': round((analytics.edge_visits / total_browser_visits * 100), 1) if total_browser_visits > 0 else 0,
                'color': '#0078D7',
                'icon': 'browser-edge'
            },
            {
                'name': 'Other',
                'count': analytics.other_browsers,
                'percentage': round((analytics.other_browsers / total_browser_visits * 100), 1) if total_browser_visits > 0 else 0,
                'color': '#6B7280',
                'icon': 'browser'
            }
        ]
        
        # Get time series data for charts
        time_series_data = analytics.get_time_series_data(days=30)
        
        context.update({
            'analytics': analytics,
            'weekly_stats': weekly_stats,
            'monthly_stats': monthly_stats,
            'trends': trends,
            'traffic_sources': traffic_sources,
            'devices': devices,
            'browsers': browsers,
            'time_series_data': time_series_data,
            'now': now
        })
        
        return context

def analytics_data(request, pk):
    """API endpoint for fetching analytics data"""
    project = get_object_or_404(Project, pk=pk)
    if project.author != request.user and not request.user.is_staff:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    
    analytics = project.analytics
    time_range = request.GET.get('range', 'week')
    
    if time_range == 'week':
        days = 7
    elif time_range == 'month':
        days = 30
    else:
        days = 365
    
    data = analytics.get_time_series_data(days=days)
    
    return JsonResponse(data)

def export_analytics_csv(request, pk):
    """Export analytics data as CSV"""
    project = get_object_or_404(Project, pk=pk)
    if project.author != request.user and not request.user.is_staff:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    
    analytics = project.analytics
    
    # Create CSV data
    output = StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'Date', 'Views', 'Unique Visitors', 'GitHub Clicks',
        'Average Time (minutes)', 'Comments', 'Claps'
    ])
    
    # Get daily data for the last 30 days
    data = analytics.get_time_series_data(days=30)
    for entry in data['daily_data']:
        writer.writerow([
            entry['date'],
            entry['views'],
            entry['visitors'],
            entry['github_clicks'],
            round(entry['avg_time_spent'] / 60, 2),
            entry['comments'],
            entry['clap_count']
        ])
    
    # Create the HTTP response with CSV data
    response = HttpResponse(output.getvalue(), content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="{project.slug}-analytics.csv"'
    
    return response

def export_analytics_pdf(request, pk):
    """Export analytics data as PDF"""
    if not request.method == 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    project = get_object_or_404(Project, pk=pk)
    if project.author != request.user and not request.user.is_staff:
        return JsonResponse({'error': 'Permission denied'}, status=403)
    
    data = json.loads(request.body)
    chart_images = data.get('charts', {})
    date_range = data.get('dateRange', 'week')
    
    # Generate PDF using the utility function
    pdf_file = generate_analytics_pdf(project, chart_images, date_range)
    
    response = HttpResponse(pdf_file, content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="{project.slug}-analytics.pdf"'
    
    return response

def get_popular_tags():
    """Helper function to get popular tags"""
    return (Project.objects
            .values('tags')
            .annotate(count=Count('id'))
            .order_by('-count')
            .exclude(tags='')[:10])

def get_client_info(request):
    """Get basic client information without user-agents package"""
    info = {
        'is_mobile': request.META.get('HTTP_USER_AGENT', '').lower().find('mobile') > -1,
        'browser': 'other',
        'ip': request.META.get('REMOTE_ADDR'),
        'referrer': request.META.get('HTTP_REFERER', ''),
    }
    
    user_agent = request.META.get('HTTP_USER_AGENT', '').lower()
    if 'chrome' in user_agent:
        info['browser'] = 'chrome'
    elif 'firefox' in user_agent:
        info['browser'] = 'firefox'
    elif 'safari' in user_agent:
        info['browser'] = 'safari'
    elif 'edge' in user_agent:
        info['browser'] = 'edge'
    
    return info

def update_analytics(request, project):
    """Update project analytics"""
    analytics, created = ProjectAnalytics.objects.get_or_create(project=project)
    client_info = get_client_info(request)
    
    # Update view count
    analytics.view_count += 1
    
    # Update device stats
    if client_info['is_mobile']:
        analytics.mobile_visits += 1
    else:
        analytics.desktop_visits += 1
    
    # Update browser stats
    if client_info['browser'] == 'chrome':
        analytics.chrome_visits += 1
    elif client_info['browser'] == 'firefox':
        analytics.firefox_visits += 1
    elif client_info['browser'] == 'safari':
        analytics.safari_visits += 1
    elif client_info['browser'] == 'edge':
        analytics.edge_visits += 1
    else:
        analytics.other_browsers += 1
    
    # Update traffic sources
    referrer = client_info['referrer']
    if not referrer:
        analytics.direct_traffic += 1
    elif 'google' in referrer or 'bing' in referrer:
        analytics.search_traffic += 1
    elif 'facebook' in referrer or 'twitter' in referrer or 'linkedin' in referrer:
        analytics.social_traffic += 1
    else:
        analytics.referral_traffic += 1
    
    # Update unique visitors
    visitor_key = f"visitor_{client_info['ip']}_{project.id}"
    if not cache.get(visitor_key):
        analytics.unique_visitors += 1
        cache.set(visitor_key, True, timeout=86400)  # 24 hours
        
        # Update weekly and monthly unique visitors
        now = timezone.now()
        week_ago = now - timedelta(days=7)
        month_ago = now - timedelta(days=30)
        
        if not cache.get(f"{visitor_key}_weekly"):
            analytics.unique_visitors_weekly += 1
            cache.set(f"{visitor_key}_weekly", True, timeout=604800)  # 7 days
            
        if not cache.get(f"{visitor_key}_monthly"):
            analytics.unique_visitors_monthly += 1
            cache.set(f"{visitor_key}_monthly", True, timeout=2592000)  # 30 days
    
    analytics.save()

def project_list(request):
    """List and search projects"""
    search_form = ProjectSearchForm(request.GET)
    projects = Project.objects.all()
    
    if search_form.is_valid():
        query = search_form.cleaned_data.get('query')
        tags = search_form.cleaned_data.get('tags')
        sort = search_form.cleaned_data.get('sort')
        
        if query:
            projects = projects.filter(
                Q(title__icontains=query) |
                Q(description__icontains=query) |
                Q(author__username__icontains=query) |
                Q(tags__icontains=query)
            )
        
        if tags:
            for tag in tags:
                projects = projects.filter(tags__icontains=tag)
        
        if sort:
            projects = projects.order_by(sort)
        else:
            projects = projects.order_by('-created_at')
    else:
        projects = projects.order_by('-created_at')
    
    # Get per_page parameter from request, default to 12
    per_page = request.GET.get('per_page', 12)
    try:
        per_page = int(per_page)
        # Limit per_page to valid options
        if per_page not in [12, 24, 48]:
            per_page = 12
    except ValueError:
        per_page = 12
    
    # Pagination with dynamic per_page
    paginator = Paginator(projects, per_page)
    page = request.GET.get('page', 1)
    
    try:
        page_obj = paginator.page(page)
    except PageNotAnInteger:
        page_obj = paginator.page(1)
    except EmptyPage:
        page_obj = paginator.page(paginator.num_pages)
    
    # Get popular tags
    popular_tags = (Project.objects
        .values_list('tags', flat=True)
        .exclude(tags='')
        .annotate(count=Count('id'))
        .order_by('-count')[:10])
    
    context = {
        'page_obj': page_obj,
        'popular_tags': popular_tags,
        'search_form': search_form,
        'per_page': per_page,
    }
    return render(request, 'projects/project_list.html', context)

@login_required
def submit_project(request):
    if request.method == 'POST':
        form = ProjectForm(request.POST, request.FILES, user=request.user)
        if form.is_valid():
            project = form.save(commit=False)
            project.author = request.user
            
            # Handle gold seed fields for faculty
            if request.user.groups.filter(name='Faculty').exists():
                project.is_gold = form.cleaned_data.get('is_gold', False)
                if project.is_gold:
                    project.token_reward = form.cleaned_data.get('token_reward')
                    project.gold_goal = form.cleaned_data.get('gold_goal')
                    project.deadline = form.cleaned_data.get('deadline')
            
            project.save()
            
            # Handle tags
            if form.cleaned_data['tags']:
                project.tags = form.cleaned_data['tags']
            
            messages.success(request, 'Project submitted successfully!')
            return redirect('projects:project_detail', pk=project.pk)
    else:
        form = ProjectForm(user=request.user)
    
    return render(request, 'projects/submit_project.html', {
        'form': form,
        'title': 'Submit Seed'
    })


def project_detail(request, pk):
    project = get_object_or_404(Project, pk=pk)
    comments = project.comments.filter(parent=None).select_related('user').prefetch_related(
        'replies', 
        'claps',
        'replies__claps',
        'replies__user'
    )
    
    # Handle POST requests (new comments)
    if request.method == 'POST' and request.user.is_authenticated:
        form = CommentForm(request.POST, request.FILES)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.project = project
            comment.user = request.user
            
            # Handle replies
            parent_id = request.POST.get('parent_id')
            if parent_id:
                try:
                    parent_comment = Comment.objects.get(id=parent_id)
                    comment.parent = parent_comment
                    # Create notification for parent comment author
                    if parent_comment.user != request.user:
                        Notification.objects.create(
                            recipient=parent_comment.user,
                            sender=request.user,
                            project=project,
                            notification_type='comment',
                            message=f"{request.user.username} replied to your comment"
                        )
                except Comment.DoesNotExist:
                    messages.error(request, 'Parent comment not found.')
                    return redirect('projects:project_detail', pk=pk)
            
            comment.save()
            
            # Create notification for project author (only for top-level comments)
            if project.author != request.user and not parent_id:
                Notification.objects.create(
                    recipient=project.author,
                    sender=request.user,
                    project=project,
                    notification_type='comment',
                    message=f"{request.user.username} commented on your project"
                )
            
            messages.success(request, 'Comment added successfully!')
            return redirect('projects:project_detail', pk=pk)
        else:
            messages.error(request, 'Error posting comment. Please check your input.')
    else:
        form = CommentForm()
    
    # Check clap status for authenticated users
    if request.user.is_authenticated:
        # Check if user has clapped for the project
        project.user_has_clapped = project.claps.filter(user=request.user).exists()
        
        # Check if user has clapped for comments
        for comment in comments:
            comment.has_user_clapped = comment.claps.filter(user=request.user).exists()
            for reply in comment.replies.all():
                reply.has_user_clapped = reply.claps.filter(user=request.user).exists()
        
        # Get user's bookmark if it exists
        user_bookmark = project.bookmarks.filter(user=request.user).first()
    else:
        project.user_has_clapped = False
        user_bookmark = None

    # Get project statistics
    stats = {
        'view_count': project.analytics.view_count if hasattr(project, 'analytics') else 0,
        'clap_count': project.clap_count,
        'comment_count': project.comments.count(),
        'rating_count': project.rating_count,
        'avg_rating': project.average_rating,
    }
    
    context = {
        'project': project,
        'comments': comments,
        'comment_form': form,
        'featured_image_url': project.get_featured_image_url(),
        'pdf_url': project.get_pdf_url(),
        'rating_form': RatingForm(),
        'user_bookmark': user_bookmark,
        'stats': stats,

    }
    
    # Update view count
    if hasattr(project, 'analytics'):
        project.analytics.view_count += 1
        project.analytics.save()
    
    return render(request, 'projects/project_detail.html', context)

@login_required
def rate_project(request, pk):
    if request.method == 'POST':
        project = get_object_or_404(Project, pk=pk)
        score = request.POST.get('score')
        review = request.POST.get('review', '')
        
        try:
            score = int(score)
            if not (1 <= score <= 5):
                return JsonResponse({'status': 'error', 'message': 'Invalid rating'}, status=400)
                
            rating, created = Rating.objects.update_or_create(
                project=project,
                user=request.user,
                defaults={
                    'score': score,
                    'review': review
                }
            )
            
            # Update project rating stats
            project.update_rating_stats()
            
            # Create notification for project author if it's a new rating
            if created and project.author != request.user:
                Notification.objects.create(
                    recipient=project.author,
                    sender=request.user,
                    project=project,
                    notification_type='rating',
                    message=f"{request.user.username} rated your project"
                )
            
            return JsonResponse({
                'status': 'success',
                'rating': project.average_rating,
                'total_ratings': project.rating_count
            })
            
        except (ValueError, TypeError) as e:
            return JsonResponse({'status': 'error', 'message': str(e)}, status=400)
            
    return JsonResponse({'status': 'error', 'message': 'Invalid request'}, status=400)

@login_required
def toggle_bookmark(request, pk):
    project = get_object_or_404(Project, pk=pk)
    bookmark, created = Bookmark.objects.get_or_create(
        project=project,
        user=request.user,
        defaults={'notes': ''}
    )
    
    if not created:
        bookmark.delete()
        return JsonResponse({'status': 'removed'})
    
    return JsonResponse({'status': 'added'})

@login_required
def update_bookmark_notes(request, pk):
    bookmark = get_object_or_404(Bookmark, project_id=pk, user=request.user)
    
    if request.method == 'POST':
        form = BookmarkForm(request.POST, instance=bookmark)
        if form.is_valid():
            form.save()
            return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error'}, status=400)

@login_required
def bookmarks(request):
    bookmarks = Bookmark.objects.filter(user=request.user).select_related('project')
    return render(request, 'projects/bookmarks.html', {'bookmarks': bookmarks})



@login_required
def edit_profile(request):
    try:
        profile = request.user.profile
    except Profile.DoesNotExist:
        profile = Profile.objects.create(user=request.user)

    if request.method == 'POST':
        form = ProfileForm(request.POST, request.FILES, instance=profile)
        if form.is_valid():
            form.save()
            messages.success(request, 'Profile updated successfully!')
            return redirect('projects:user_profile', username=request.user.username)
    else:
        form = ProfileForm(instance=profile)

    return render(request, 'projects/edit_profile.html', {
        'form': form,
        'active_tab': 'profile'
    })

@login_required
def user_profile(request, username):
    profile_user = get_object_or_404(User.objects.select_related('profile'), username=username)
    projects = Project.objects.filter(author=profile_user).order_by('-created_at')
    
    # Get follow status
    is_following = False
    if request.user.is_authenticated:
        is_following = Follow.objects.filter(
            follower=request.user,
            following=profile_user
        ).exists()
    
    # Get statistics and counts
    stats = {
        'followers_count': Follow.objects.filter(following=profile_user).count(),
        'following_count': Follow.objects.filter(follower=profile_user).count(),
        'projects_count': projects.count(),
        'total_claps': Project.objects.filter(author=profile_user).aggregate(
            total_claps=Sum('clap_count')
        )['total_claps'] or 0,
        'total_comments': Comment.objects.filter(user=profile_user).count(),
    }
    
    context = {
        'profile_user': profile_user,
        'projects': projects,
        'is_following': is_following,
        'stats': stats,
        'is_faculty': profile_user.groups.filter(name='Faculty').exists(),
    }
    return render(request, 'projects/user_profile.html', context)

def user_projects(request, username):
    user = get_object_or_404(User, username=username)
    projects = user.project_set.all().order_by('-created_at')
    
    # Filter by tag if provided
    tag = request.GET.get('tag')
    if tag:
        projects = projects.filter(tags__icontains=tag)
    
    paginator = Paginator(projects, 10)
    page = request.GET.get('page')
    projects_page = paginator.get_page(page)
    
    context = {
        'user_profile': user,
        'projects': projects_page,
        'selected_tag': tag,
    }
    return render(request, 'projects/user_projects.html', context)

@login_required
def notifications(request):
    notifications_list = request.user.notifications.all().order_by('-created_at')
    return render(request, 'projects/notifications.html', {
        'notifications': notifications_list
    })

@login_required
def mark_notification_read(request, notification_id):
    notification = get_object_or_404(Notification, id=notification_id, recipient=request.user)
    notification.is_read = True
    notification.save()
    return JsonResponse({'status': 'success'})

@login_required
def follow_user(request, username):
    user_to_follow = get_object_or_404(User, username=username)
    
    if request.user != user_to_follow:
        follow, created = Follow.objects.get_or_create(
            follower=request.user,
            following=user_to_follow
        )
        
        if created:
            # Create notification for the followed user
            Notification.objects.create(
                recipient=user_to_follow,
                sender=request.user,
                notification_type='follow',
                message=f'{request.user.username} started following you'
            )
    
    return redirect('projects:user_profile', username=username)

@login_required
def unfollow_user(request, username):
    user_to_unfollow = get_object_or_404(User, username=username)
    
    Follow.objects.filter(
        follower=request.user,
        following=user_to_unfollow
    ).delete()
    
    return redirect('projects:user_profile', username=username)

def search_projects(request):
    """Advanced search view"""
    form = AdvancedSearchForm(request.GET)
    projects = Project.objects.all()
    
    if form.is_valid():
        # Apply filters using ProjectFilter
        project_filter = ProjectFilter(request.GET, queryset=projects)
        projects = project_filter.qs
        
        # Apply sorting
        sort_by = form.cleaned_data.get('sort_by')
        if sort_by:
            if sort_by == '-rating_avg':
                # Annotate with average rating
                projects = projects.annotate(
                    rating_avg=Avg('ratings__score')
                ).order_by('-rating_avg')
            elif sort_by == '-comment_count':
                # Annotate with comment count
                projects = projects.annotate(
                    comment_count=Count('comments')
                ).order_by('-comment_count')
            else:
                projects = projects.order_by(sort_by)
    
    # Annotate with additional metrics for display
    projects = projects.annotate(
        comment_count=Count('comments'),
        rating_avg=Avg('ratings__score')
    )
    
    # Pagination
    paginator = Paginator(projects, settings.MAX_PROJECTS_PER_PAGE)
    page = request.GET.get('page')
    try:
        projects = paginator.page(page)
    except PageNotAnInteger:
        projects = paginator.page(1)
    except EmptyPage:
        projects = paginator.page(paginator.num_pages)
    
    context = {
        'form': form,
        'projects': projects,
        'popular_tags': get_popular_tags(),
        'total_results': paginator.count,
    }
    
    if request.headers.get('HX-Request'):
        # Return partial template for HTMX requests
        return render(request, 'projects/includes/project_list_results.html', context)
    
    return render(request, 'projects/search.html', context)

@login_required
def bookmark_project(request, pk):
    """Add or remove a project bookmark"""
    project = get_object_or_404(Project, pk=pk)
    bookmark, created = Bookmark.objects.get_or_create(
        user=request.user,
        project=project
    )
    
    if not created:
        # If bookmark already existed, remove it
        bookmark.delete()
        messages.success(request, 'Bookmark removed.')
        return JsonResponse({
            'status': 'success',
            'action': 'removed',
            'message': 'Project removed from bookmarks'
        })
    
    # Create notification for project author
    if project.author != request.user:
        Notification.create_notification(
            recipient=project.author,
            sender=request.user,
            notification_type='bookmark',
            project=project
        )
    
    messages.success(request, 'Project bookmarked successfully.')
    return JsonResponse({
        'status': 'success',
        'action': 'added',
        'message': 'Project added to bookmarks'
    })

class RegisterView(CreateView):
    form_class = ExtendedUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/register.html'

    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, 'Registration successful! Please log in.')
        return response

def get_monthly_contributions():
    """Get users sorted by their contributions in the current month"""
    start_of_month = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    
    return User.objects.annotate(
        monthly_projects=Count(
            'project',
            filter=Q(project__created_at__gte=start_of_month)
        ),
        monthly_comments=Count(
            'comment',
            filter=Q(comment__created_at__gte=start_of_month)
        ),
        monthly_claps=Count(
            'user_claps',
            filter=Q(user_claps__created_at__gte=start_of_month)
        ),
        # Calculate total directly in the same annotation
        total_contributions=Count(
            'project',
            filter=Q(project__created_at__gte=start_of_month)
        ) + Count(
            'comment',
            filter=Q(comment__created_at__gte=start_of_month)
        ) + Count(
            'user_claps',
            filter=Q(user_claps__created_at__gte=start_of_month)
        )
    ).order_by('-total_contributions')

def leaderboard_view(request):
    """View for the leaderboard page"""
    contributions = get_monthly_contributions()
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        # Return JSON for React component
        data = [{
            'rank': idx + 1,
            'user': user.username,
            'contributions': user.total_contributions,
            'projects': user.projects_count,
            'clap_count': user.claps_received or 0,
            'change': 0  # Calculate change from previous position
        } for idx, user in enumerate(contributions)]
        return JsonResponse({'leaderboard': data})
    
    return render(request, 'projects/leaderboard.html', {
        'contributions': contributions
    })


#####
# views.py (add these methods)



@login_required
def edit_project(request, pk):
    project = get_object_or_404(Project, pk=pk)
    
    # Check if user is author
    if project.author != request.user:
        messages.error(request, "You don't have permission to edit this project.")
        return redirect('projects:project_detail', pk=project.pk)
    
    if request.method == 'POST':
        form = ProjectForm(
            request.POST,
            request.FILES,
            instance=project,
            user=request.user
        )
        if form.is_valid():
            project = form.save(commit=False)
            
            # Handle gold seed fields for faculty
            if request.user.groups.filter(name='Faculty').exists():
                project.is_gold = form.cleaned_data.get('is_gold', False)
                if project.is_gold:
                    project.token_reward = form.cleaned_data.get('token_reward')
                    project.gold_goal = form.cleaned_data.get('gold_goal')
                    project.deadline = form.cleaned_data.get('deadline')
                else:
                    # Clear gold seed fields if is_gold is False
                    project.token_reward = None
                    project.gold_goal = None
                    project.deadline = None
            
            project.save()
            messages.success(request, 'Project updated successfully!')
            return redirect('projects:project_detail', pk=project.pk)
    else:
        # Initialize form with existing project data
        initial_data = {
            'is_gold': project.is_gold,
            'token_reward': project.token_reward,
            'gold_goal': project.gold_goal,
        }
        if project.deadline:
            initial_data['deadline'] = project.deadline.strftime('%Y-%m-%dT%H:%M')
            
        form = ProjectForm(
            instance=project,
            user=request.user,
            initial=initial_data
        )
    
    return render(request, 'projects/edit_project.html', {
        'form': form,
        'project': project,
        'title': 'Edit Project'
    })

@login_required
def delete_project(request, pk):
    project = get_object_or_404(Project, pk=pk)
    
    # Delete associated files
    if project.featured_image:
        project.featured_image.delete()
    if project.pdf_file:
        project.pdf_file.delete()
    if project.additional_files:
        project.additional_files.delete()
        
    # Delete analytics data
    ProjectAnalytics.objects.filter(project=project).delete()
    
    # Delete notifications related to this project
    Notification.objects.filter(project=project).delete()
    
    # Delete the project
    project.delete()
    
    messages.success(request, 'Project deleted successfully')
    return redirect('projects:project_list')

@login_required
def clap_project(request, pk):
    if request.method == 'POST':
        project = get_object_or_404(Project, pk=pk)
        clap, created = Clap.objects.get_or_create(user=request.user, project=project)
        if created:
            project.clap_count += 1  # Use clap_count instead of clap_count
            project.save()
            return JsonResponse({'status': 'success', 'clap_count': project.clap_count})
    return JsonResponse({'status': 'error'}, status=400)

@login_required
def edit_comment(request, pk):
    comment = get_object_or_404(Comment, pk=pk)
    if comment.user != request.user:
        raise PermissionDenied
    
    if request.method == 'POST':
        form = CommentForm(request.POST, request.FILES, instance=comment)
        if form.is_valid():
            comment = form.save()
            return redirect('projects:project_detail', pk=comment.project.pk)
    else:
        form = CommentForm(instance=comment)
    return render(request, 'projects/edit_comment.html', {'form': form, 'comment': comment})

@login_required
def delete_comment(request, pk):
    comment = get_object_or_404(Comment, pk=pk)
    
    # Check permissions
    if comment.user != request.user and comment.project.author != request.user:
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'status': 'error', 'message': 'Permission denied'}, status=403)
        messages.error(request, 'You do not have permission to delete this comment.')
        return redirect('projects:project_detail', pk=comment.project.pk)
    
    try:
        project_pk = comment.project.pk
        comment.delete()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'status': 'success'})
        
        messages.success(request, 'Comment deleted successfully.')
        return redirect('projects:project_detail', pk=project_pk)
    
    except Exception as e:
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)
        messages.error(request, f'Error deleting comment: {str(e)}')
        return redirect('projects:project_detail', pk=comment.project.pk)

@login_required
def mark_all_notifications_read(request):
    request.user.notifications.filter(is_read=False).update(is_read=True)
    return JsonResponse({'status': 'success'})

# API Views
class ProjectListAPI(generics.ListAPIView):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated]

class ProjectDetailAPI(generics.RetrieveAPIView):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated]

class ProjectAnalyticsAPI(generics.RetrieveAPIView):
    queryset = Project.objects.all()
    serializer_class = ProjectAnalyticsSerializer
    permission_classes = [IsAuthenticated]
    
    def get_object(self):
        project = super().get_object()
        if project.author != self.request.user and not self.request.user.is_staff:
            raise PermissionDenied
        return project.analytics

@login_required
def profile_settings(request):
    try:
        user_profile = request.user.profile
    except UserProfile.DoesNotExist:
        user_profile = UserProfile.objects.create(user=request.user)

    if request.method == 'POST':
        form = NotificationSettingsForm(request.POST)
        if form.is_valid():
            # Update notification settings
            user_profile.email_on_comment = form.cleaned_data['email_on_comment']
            user_profile.email_on_follow = form.cleaned_data['email_on_follow']
            user_profile.email_on_clap = form.cleaned_data['email_on_clap']
            user_profile.email_on_bookmark = form.cleaned_data['email_on_bookmark']
            user_profile.save()
            
            messages.success(request, 'Notification settings updated successfully!')
            return redirect('projects:profile_settings')
    else:
        # Initialize form with current settings
        form = NotificationSettingsForm(initial={
            'email_on_comment': user_profile.email_on_comment,
            'email_on_follow': user_profile.email_on_follow,
            'email_on_clap': user_profile.email_on_clap,
            'email_on_bookmark': user_profile.email_on_bookmark,
        })

    return render(request, 'projects/profile_settings.html', {
        'form': form,
        'active_tab': 'settings'
    })



# Add to projects/views.py
def custom_404(request, exception):
    return render(request, 'errors/404.html', status=404)

def custom_500(request):
    return render(request, 'errors/500.html', status=500)

def homepage(request):
    """Homepage view showing featured projects and recent activity"""
    # Get recent projects
    recent_projects = Project.objects.select_related('author').prefetch_related('comments').order_by('-created_at')[:6]
    
    # Get trending projects (most clap_count in last 7 days)
    week_ago = timezone.now() - timedelta(days=7)
    trending_projects = Project.objects.annotate(
        recent_claps=Count('clap_count', filter=Q(claps__created_at__gte=week_ago))
    ).order_by('-recent_claps', '-created_at')[:3]
    
    # Get top contributors
    top_contributors = get_monthly_contributions()[:5]
    
    # Get latest comments
    latest_comments = Comment.objects.select_related('user', 'project').order_by('-created_at')[:5]
    
    context = {
        'recent_projects': recent_projects,
        'trending_projects': trending_projects,
        'top_contributors': top_contributors,
        'latest_comments': latest_comments,
        'total_projects': Project.objects.count(),
        'total_users': User.objects.count(),
    }
    
    return render(request, 'projects/homepage.html', context)

def faculty_page(request):
    """View for the faculty page"""
    faculty_members = User.objects.filter(
        groups__name='Faculty'
    ).select_related('profile')
    
    context = {
        'faculty_members': faculty_members,
        'page_title': 'Faculty Members',
        'active_tab': 'faculty'
    }
    return render(request, 'projects/faculty_page.html', context)

def careers_page(request):
    return render(request, 'projects/careers.html', {
        'page_title': 'Careers',
        'active_tab': 'careers'
    })

@login_required
def clap_comment(request, pk):
    if request.method == 'POST':
        comment = get_object_or_404(Comment, pk=pk)
        clap, created = CommentClap.objects.get_or_create(user=request.user, comment=comment)
        if created:
            comment.clap_count += 1
            comment.save()
            return JsonResponse({
                'status': 'success', 
                'claps': comment.clap_count,
                'commentId': comment.id
            })
        else:
            # Remove clap if already clapped
            clap.delete()
            comment.clap_count -= 1
            comment.save()
            return JsonResponse({
                'status': 'removed',
                'claps': comment.clap_count,
                'commentId': comment.id
            })
    return JsonResponse({'status': 'error'}, status=400)

def get_similar_projects(project, limit=3):
    """Returns similar projects based on tags"""
    if not project.tags:
        return Project.objects.exclude(id=project.id)[:limit]
    
    tags = [tag.strip() for tag in project.tags.split(',')]
    similar_projects = Project.objects.filter(
        tags__icontains=tags[0]
    ).exclude(id=project.id)
    
    for tag in tags[1:]:
        similar_projects = similar_projects | Project.objects.filter(
            tags__icontains=tag
        ).exclude(id=project.id)
    
    return similar_projects.distinct()[:limit]

def talents_page(request):
    # Get selected talent type from query params
    talent_type = request.GET.get('talent_type', '')
    
    # Base queryset
    talents = User.objects.annotate(
        project_count=Count('project'),
        follower_count=Count('followers'),
        following_count=Count('following')
    ).filter(
        ~Q(groups__name='Faculty'),
        is_active=True
    ).select_related('profile')
    
    # Apply talent type filter if selected
    if talent_type:
        talents = talents.filter(profile__talent_type=talent_type)
    
    talents = talents.order_by('-project_count')
    
    context = {
        'talents': talents,
        'title': 'Our Talents',
        'talent_types': TALENT_TYPES,
        'selected_talent': talent_type
    }
    return render(request, 'projects/talents.html', context)

@login_required
def submit_solution(request, pk):
    project = get_object_or_404(Project, pk=pk)
    
    # Check if project is a gold seed and still accepting submissions
    if not project.is_gold or not project.can_submit():
        messages.error(request, 'This project is not accepting submissions')
        return redirect('projects:project_detail', pk=pk)
    
    # Check if user already submitted
    if Solution.objects.filter(project=project, user=request.user).exists():
        messages.error(request, 'You have already submitted a solution')
        return redirect('projects:project_detail', pk=pk)
    
    if request.method == 'POST':
        form = SolutionForm(request.POST, request.FILES)
        if form.is_valid():
            solution = form.save(commit=False)
            solution.project = project
            solution.user = request.user
            solution.save()
            messages.success(request, 'Solution submitted successfully!')
            return redirect('projects:project_detail', pk=pk)
    else:
        form = SolutionForm()
    
    return render(request, 'projects/submit_solution.html', {
        'form': form,
        'project': project
    })

@login_required
def review_solution(request, project_pk, solution_pk):
    solution = get_object_or_404(Solution, pk=solution_pk, project_id=project_pk)
    project = solution.project
    
    # Check if user is faculty and project author
    if not request.user.groups.filter(name='Faculty').exists() or request.user != project.author:
        messages.error(request, 'You do not have permission to review solutions')
        return redirect('projects:project_detail', pk=project_pk)
    
    if request.method == 'POST':
        is_approved = request.POST.get('is_approved') == 'true'
        feedback = request.POST.get('feedback', '')
        tokens = request.POST.get('tokens')
        
        solution.is_approved = is_approved
        solution.faculty_feedback = feedback
        if tokens and is_approved:
            solution.tokens_awarded = int(tokens)
        solution.save()
        
        messages.success(request, 'Solution review submitted successfully')
        return redirect('projects:project_detail', pk=project_pk)
    
    return render(request, 'projects/review_solution.html', {
        'solution': solution,
        'project': project
    })

@login_required
def join_team(request, team_slug):
    team = get_object_or_404(Team, slug=team_slug)
    
    # Check if user is already a member
    if TeamMembership.objects.filter(team=team, user=request.user).exists():
        messages.warning(request, 'You are already a member of this team.')
        return redirect('projects:team_detail', team_slug=team.slug)
    
    # Create membership
    TeamMembership.objects.create(
        team=team,
        user=request.user,
        role='member',
        is_approved=True  # Auto-approve for now, you can modify this for approval workflow
    )
    
    messages.success(request, f'You have successfully joined {team.name}!')
    return redirect('projects:team_detail', team_slug=team.slug)

@login_required
def leave_team(request, team_slug):
    team = get_object_or_404(Team, slug=team_slug)
    membership = get_object_or_404(TeamMembership, team=team, user=request.user)
    
    # Prevent founder from leaving
    if membership.role == 'founder':
        messages.error(request, 'Team founders cannot leave their team. Transfer ownership first or delete the team.')
        return redirect('projects:team_detail', team_slug=team.slug)
    
    # Delete membership
    membership.delete()
    
    messages.success(request, f'You have left {team.name}.')
    return redirect('projects:team_list')

@login_required
def promote_member(request, team_slug, user_id):
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])
    
    team = get_object_or_404(Team, slug=team_slug)
    
    # Check if current user is founder
    if not TeamMembership.objects.filter(
        team=team,
        user=request.user,
        role='founder',
        is_approved=True
    ).exists():
        messages.error(request, 'Only team founders can promote members.')
        return redirect('projects:team_members', team_slug=team.slug)
    
    # Get target member
    membership = get_object_or_404(
        TeamMembership,
        team=team,
        user_id=user_id,
        is_approved=True
    )
    
    # Prevent promoting founder
    if membership.role == 'founder':
        messages.error(request, 'Cannot promote team founder.')
        return redirect('projects:team_members', team_slug=team.slug)
    
    # Promote to moderator
    membership.role = 'moderator'
    membership.save()
    
    messages.success(
        request, 
        f'{membership.user.get_full_name() or membership.user.username} has been promoted to moderator.'
    )
    return redirect('projects:team_members', team_slug=team.slug)

@login_required
def remove_member(request, team_slug, user_id):
    if request.method != 'POST':
        return HttpResponseNotAllowed(['POST'])
    
    team = get_object_or_404(Team, slug=team_slug)
    
    # Check if current user is founder or moderator
    current_membership = get_object_or_404(
        TeamMembership,
        team=team,
        user=request.user,
        is_approved=True,
        role__in=['founder', 'moderator']
    )
    
    # Get target member
    membership = get_object_or_404(
        TeamMembership,
        team=team,
        user_id=user_id
    )
    
    # Prevent removing founder
    if membership.role == 'founder':
        messages.error(request, 'Cannot remove team founder.')
        return redirect('projects:team_members', team_slug=team.slug)
    
    # Prevent moderators from removing other moderators
    if current_membership.role == 'moderator' and membership.role == 'moderator':
        messages.error(request, 'Moderators cannot remove other moderators.')
        return redirect('projects:team_members', team_slug=team.slug)
    
    # Remove member
    membership.delete()
    
    messages.success(
        request, 
        f'{membership.user.get_full_name() or membership.user.username} has been removed from the team.'
    )
    return redirect('projects:team_members', team_slug=team.slug)

@login_required
def team_list(request):
    """
    Display a list of all teams with search and filter capabilities
    """
    teams = Team.objects.all().select_related('founder')
    
    # Search functionality
    search_query = request.GET.get('search', '')
    if search_query:
        teams = teams.filter(
            Q(name__icontains=search_query) |
            Q(description__icontains=search_query) |
            Q(tags__icontains=search_query)
        ).distinct()
    
    # Filter by tags
    tag_filter = request.GET.get('tag', '')
    if tag_filter:
        teams = teams.filter(tags__icontains=tag_filter)
    
    # Get all unique tags for the filter dropdown
    all_tags = set()
    for team in Team.objects.values_list('tags', flat=True):
        if team:  # Check if tags exist
            all_tags.update(tag.strip() for tag in team.split(','))
    
    context = {
        'teams': teams,
        'search_query': search_query,
        'tag_filter': tag_filter,
        'all_tags': sorted(all_tags),
        'title': 'Teams'
    }
    
    return render(request, 'teams/team_list.html', context)

@login_required
def create_team(request):
    """
    Handle team creation
    """
    if request.method == 'POST':
        form = TeamForm(request.POST, request.FILES)
        if form.is_valid():
            team = form.save(commit=False)
            team.founder = request.user
            team.save()
            
            # Create founder membership
            TeamMembership.objects.create(
                team=team,
                user=request.user,
                role='founder',
                is_approved=True
            )
            
            messages.success(request, f'Team "{team.name}" has been created successfully!')
            return redirect('projects:team_detail', team_slug=team.slug)
    else:
        form = TeamForm()
    
    return render(request, 'teams/create_team.html', {
        'form': form,
        'title': 'Create Team'
    })

@login_required
def team_detail(request, team_slug):
    """
    Display team details, members, and activities
    """
    team = get_object_or_404(Team, slug=team_slug)
    
    # Get user's membership if exists
    user_membership = TeamMembership.objects.filter(
        team=team,
        user=request.user
    ).first()
    
    # Get team members with profiles
    members = TeamMembership.objects.filter(
        team=team,
        is_approved=True
    ).select_related('user', 'user__profile').order_by('-role', 'user__username')
    
    # Get recent activities (if you have an Activity model)
    # activities = team.activities.all().select_related('user')[:5]
    
    context = {
        'team': team,
        'user_membership': user_membership,
        'members': members,
        # 'activities': activities,
        'title': team.name,
        'tags': [tag.strip() for tag in team.tags.split(',')] if team.tags else []
    }
    
    return render(request, 'teams/team_detail.html', context)

@login_required
def edit_team(request, team_slug):
    """
    Handle team editing
    """
    team = get_object_or_404(Team, slug=team_slug)
    
    # Check if user is founder or moderator
    membership = get_object_or_404(
        TeamMembership, 
        team=team, 
        user=request.user, 
        is_approved=True,
        role__in=['founder', 'moderator']
    )
    
    if request.method == 'POST':
        form = TeamForm(request.POST, request.FILES, instance=team)
        if form.is_valid():
            team = form.save()
            messages.success(request, f'Team "{team.name}" has been updated successfully!')
            return redirect('projects:team_detail', team_slug=team.slug)
    else:
        form = TeamForm(instance=team)
    
    context = {
        'form': form,
        'team': team,
        'title': f'Edit Team: {team.name}',
        'can_delete': membership.role == 'founder'  # Only founders can delete teams
    }
    
    return render(request, 'teams/edit_team.html', context)

@login_required
def delete_team(request, team_slug):
    """
    Handle team deletion
    """
    team = get_object_or_404(Team, slug=team_slug)
    
    # Check if user is founder
    if not TeamMembership.objects.filter(
        team=team,
        user=request.user,
        role='founder',
        is_approved=True
    ).exists():
        messages.error(request, 'Only team founders can delete teams.')
        return redirect('projects:team_detail', team_slug=team.slug)
    
    if request.method == 'POST':
        # Store team name for success message
        team_name = team.name
        
        # Delete team image if it exists
        if team.team_image:
            team.team_image.delete(save=False)
        
        # Delete the team and all related objects
        team.delete()
        
        messages.success(request, f'Team "{team_name}" has been deleted successfully.')
        return redirect('projects:team_list')
    
    return render(request, 'teams/delete_team.html', {
        'team': team,
        'title': f'Delete Team: {team.name}'
    })

@login_required
def team_members(request, team_slug):
    """
    Display and manage team members
    """
    team = get_object_or_404(Team, slug=team_slug)
    
    # Get user's membership if exists
    user_membership = TeamMembership.objects.filter(
        team=team,
        user=request.user,
        is_approved=True
    ).first()
    
    # Check if user is a member
    if not user_membership:
        messages.error(request, 'You must be a team member to view this page.')
        return redirect('projects:team_detail', team_slug=team.slug)
    
    # Get all team members with profiles
    members = TeamMembership.objects.filter(
        team=team,
        is_approved=True
    ).select_related(
        'user',
        'user__profile'
    ).order_by(
        # Order by role (founder first, then moderators, then members)
        Case(
            When(role='founder', then=0),
            When(role='moderator', then=1),
            default=2
        ),
        'user__username'
    )
    
    # Get pending join requests if user is founder or moderator
    pending_requests = []
    if user_membership.role in ['founder', 'moderator']:
        pending_requests = TeamMembership.objects.filter(
            team=team,
            is_approved=False
        ).select_related('user', 'user__profile')
    
    context = {
        'team': team,
        'user_membership': user_membership,
        'members': members,
        'pending_requests': pending_requests,
        'title': f'{team.name} - Members',
        'can_manage': user_membership.role in ['founder', 'moderator']
    }
    
    return render(request, 'teams/team_members.html', context)

def help_view(request):
    return render(request, 'help.html', {
        'active_tab': 'Help'
    })


    ############################




# Class-based views for new features
class StartupListView(generic.ListView):
    model = Startup
    template_name = 'projects/startups/startup_list.html'
    context_object_name = 'startups'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['products'] = Product.objects.all()
        return context

class StartupCreateView(LoginRequiredMixin, generic.CreateView):
    model = Startup
    form_class = StartupForm
    template_name = 'projects/startups/startup_form.html'
    
    def form_valid(self, form):
        form.instance.founder = self.request.user
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('projects:startup_list')

class ToolListView(generic.ListView):
    model = Tool
    template_name = 'projects/tools/tool_list.html'
    context_object_name = 'tools'

class ToolCreateView(LoginRequiredMixin, generic.CreateView):
    model = Tool
    form_class = ToolForm
    template_name = 'projects/tools/tool_form.html'
    
    def get_success_url(self):
        return reverse('projects:tool_list')

class DatasetListView(generic.ListView):
    model = Dataset
    template_name = 'projects/datasets/dataset_list.html'
    context_object_name = 'datasets'

class DatasetCreateView(LoginRequiredMixin, generic.CreateView):
    model = Dataset
    form_class = DatasetForm
    template_name = 'projects/datasets/dataset_form.html'
    
    def form_valid(self, form):
        instance = form.save(commit=False)
        instance.size = instance.file.size
        return super().form_valid(form)
    
    def get_success_url(self):
        return reverse('projects:dataset_list')

class SponsorshipListView(generic.ListView):
    model = Sponsorship
    template_name = 'projects/sponsorships/sponsorship_list.html'
    context_object_name = 'sponsorships'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Group sponsorships by level
        sponsorships = {}
        for level, _ in Sponsorship.LEVELS:
            sponsorships[level] = self.get_queryset().filter(level=level)
        context['sponsorships'] = sponsorships
        return context

class VirtualMemberListView(generic.ListView):
    model = VirtualMember
    template_name = 'projects/virtual_members/virtual_member_list.html'
    context_object_name = 'virtual_members'

class ApplicationCreateView(LoginRequiredMixin, generic.CreateView):
    model = Application
    form_class = ApplicationForm
    template_name = 'projects/application_form.html'
    success_url = reverse_lazy('projects:homepage')

    def get_initial(self):
        initial = super().get_initial()
        initial['type'] = self.request.GET.get('type', 'team')
        return initial

    def get_form(self, form_class=None):
        form = super().get_form(form_class)
        application_type = self.request.GET.get('type')
        
        # Remove sponsor-specific fields for team applications
        if application_type != 'sponsor':
            del form.fields['organization']
            del form.fields['level']
        
        return form

    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, 'Your application has been submitted successfully!')
        return response

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['is_sponsor'] = self.request.GET.get('type') == 'sponsor'
        return context

@login_required
def download_project(request, pk):
    project = get_object_or_404(Project, pk=pk)
    zip_path = project.generate_zip()
    
    with open(zip_path, 'rb') as zip_file:
        response = HttpResponse(zip_file.read(), content_type='application/zip')
        response['Content-Disposition'] = f'attachment; filename="{project.slug}_project.zip"'
    
    # Clean up the temporary zip file
    os.remove(zip_path)
    return response

@login_required
def download_dataset(request, pk):
    dataset = get_object_or_404(Dataset, pk=pk)
    
    # Increment download counter
    dataset.downloads += 1
    dataset.save()
    
    response = HttpResponse(dataset.file, content_type='application/zip')
    response['Content-Disposition'] = f'attachment; filename="{dataset.name}.zip"'
    return response

class ApplicationCreateView(LoginRequiredMixin, generic.CreateView):
    model = Application
    fields = ['type', 'cover_letter', 'resume', 'additional_info']
    template_name = 'projects/application_form.html'
    
    def form_valid(self, form):
        form.instance.user = self.request.user
        return super().form_valid(form)

def faq(request):
    return render(request, 'projects/faq.html')

